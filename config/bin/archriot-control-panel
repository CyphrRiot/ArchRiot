#!/usr/bin/env python3
"""
ArchRiot Control Panel
Centralized settings interface for ArchRiot components
"""

import gi

gi.require_version("Gtk", "4.0")
gi.require_version("Gdk", "4.0")
gi.require_version("GdkPixbuf", "2.0")
from gi.repository import Gtk, Gdk, GLib, Pango, GdkPixbuf, Gio
import os
import sys
import time
from pathlib import Path


class ArchRiotDialog:
    """Reusable ArchRiot-themed dialog with proper background"""

    def __init__(self, title, content, parent_window=None):
        self.dialog = Gtk.Window()
        self.dialog.set_title(title)
        self.dialog.set_default_size(700, 600)
        self.dialog.set_resizable(True)
        self.dialog.set_modal(True)
        self.dialog.add_css_class("archriot-control-panel")

        if parent_window:
            self.dialog.set_transient_for(parent_window)

        self.create_layout(title, content)

    def create_layout(self, title, content):
        """Create the dialog layout using proven main window approach"""
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=20)
        main_box.set_margin_start(30)
        main_box.set_margin_end(30)
        main_box.set_margin_top(15)
        main_box.set_margin_bottom(20)

        # Title
        title_label = Gtk.Label()
        title_label.set_markup(
            f'<span size="28000" weight="bold" foreground="#bb9af7" font_family="Paper Mono">{title}</span>'
        )
        title_label.set_halign(Gtk.Align.CENTER)
        main_box.append(title_label)

        # Content frame - same as main window
        content_frame = Gtk.Frame()
        content_frame.set_margin_top(10)
        content_frame.add_css_class("archriot-control-panel")

        content_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=15)
        content_box.set_margin_start(20)
        content_box.set_margin_end(20)
        content_box.set_margin_top(20)
        content_box.set_margin_bottom(20)

        # Content text
        content_label = Gtk.Label()
        content_label.set_markup(
            f'<span size="12000" font_family="Paper Mono">{content}</span>'
        )
        content_label.set_wrap(True)
        content_label.set_halign(Gtk.Align.START)
        content_box.append(content_label)

        content_frame.set_child(content_box)
        main_box.append(content_frame)

        # Close button
        close_button = Gtk.Button(label="Close")
        close_button.set_halign(Gtk.Align.CENTER)
        close_button.connect("clicked", lambda x: self.dialog.close())
        # Apply Hack Nerd Font to button
        close_button.get_child().set_markup(
            '<span font_family="Paper Mono">Close</span>'
        )
        main_box.append(close_button)

        self.dialog.set_child(main_box)

    def show(self):
        """Show the dialog"""
        self.dialog.present()


# Import our configuration manager
def import_config_module():
    """Import the ArchRiot configuration system"""
    # Get script directory, handle both __file__ and execution contexts
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
    except NameError:
        # Fallback when __file__ is not defined (like in exec context)
        script_dir = os.getcwd()

    # Try from same directory first (development)
    config_script = os.path.join(script_dir, "archriot-config")

    if os.path.exists(config_script):
        # Execute the config script to get the ArchRiotConfig class
        global_vars = {}
        with open(config_script, "r") as f:
            exec(f.read(), global_vars)
        return global_vars["ArchRiotConfig"]
    else:
        # Try from installed location
        home_bin = str(
            Path.home()
            / ".local"
            / "share"
            / "archriot"
            / "config"
            / "bin"
            / "archriot-config"
        )
        if os.path.exists(home_bin):
            global_vars = {}
            with open(home_bin, "r") as f:
                exec(f.read(), global_vars)
            return global_vars["ArchRiotConfig"]
        else:
            # Create a minimal fallback config class
            class FallbackConfig:
                def __init__(self):
                    pass

                def get_pomodoro_config(self):
                    return {"enabled": True, "duration": 25}

                def get_bluelight_config(self):
                    import re
                    from pathlib import Path

                    # Read current settings from hyprland.conf
                    hyprland_config = Path.home() / ".config" / "hypr" / "hyprland.conf"
                    enabled = True
                    temperature = 3500  # fallback

                    if hyprland_config.exists():
                        content = hyprland_config.read_text()
                        # Check if hyprsunset line is commented out (disabled)
                        if re.search(r"^\s*#.*hyprsunset", content, re.MULTILINE):
                            enabled = False
                        # Extract temperature from active hyprsunset line
                        match = re.search(r"exec-once = hyprsunset -t (\d+)", content)
                        if match:
                            temperature = int(match.group(1))
                            enabled = True

                    return {"enabled": enabled, "temperature": temperature}

                def get_mullvad_config(self):
                    return {
                        "enabled": False,
                        "account_number": "",
                        "auto_connect": False,
                    }

                def get_display_config(self):
                    return {"enabled": True, "resolution": 1920, "scaling": 100}

                def get_power_config(self):
                    return {"enabled": True, "profile": "balanced"}

                def set_pomodoro_config(self, enabled, duration):
                    pass

                def set_bluelight_config(self, enabled, temperature):
                    # This is handled by the BlueLightWidget directly updating hyprland.conf
                    # No separate config file needed since hyprland.conf is the source of truth
                    pass

                def set_mullvad_config(
                    self, enabled, account_number="", auto_connect=False
                ):
                    pass

                def set_display_config(self, enabled, resolution, scaling):
                    pass

                def set_power_config(self, enabled, profile):
                    pass

                def backup_config(self, name=None):
                    return "/tmp/fallback-backup"

            return FallbackConfig


ArchRiotConfig = import_config_module()


class BaseControlWidget:
    """Base class for control widgets with toggle and value control"""

    def __init__(self, config, title, description, icon):
        self.config = config
        self.title = title
        self.description = description
        self.icon = icon
        self.timeout_id = None

        # Create main container
        self.widget = self.create_section_frame()

    def create_section_frame(self):
        """Create the main frame for this widget"""
        frame = Gtk.Frame()
        frame.set_margin_bottom(3)

        # Create main container
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        main_box.set_margin_start(10)
        main_box.set_margin_end(10)
        main_box.set_margin_top(8)
        main_box.set_margin_bottom(8)

        # Title row with toggle
        self.title_row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)

        # Title
        title_label = Gtk.Label()
        title_label.set_markup(
            f'<span size="14000" weight="bold" foreground="#bb9af7">{self.icon} {self.title}</span>'
        )
        title_label.set_halign(Gtk.Align.START)
        title_label.set_hexpand(True)
        self.title_row.append(title_label)

        main_box.append(self.title_row)

        # Controls container
        self.controls_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        main_box.append(self.controls_box)

        frame.set_child(main_box)
        return frame

    def create_toggle(self, label_text, initial_state, callback):
        """Create a toggle switch"""
        row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        label = Gtk.Label(label=label_text)
        label.set_halign(Gtk.Align.START)
        label.set_hexpand(True)

        switch = Gtk.Switch()
        switch.set_active(initial_state)
        switch.connect("notify::active", callback)

        row.append(label)
        row.append(switch)
        return row, switch

    def create_slider(
        self,
        label_text,
        min_val,
        max_val,
        step,
        current_val,
        enabled,
        marks,
        callback,
        snap_increment=None,
    ):
        """Create a slider with optional label and snapping - single reusable function for all sliders"""
        container = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        label = None
        if label_text:  # Only create label if text is provided
            label = Gtk.Label(label=label_text)
            label.set_halign(Gtk.Align.START)
            container.append(label)

        scale = Gtk.Scale.new_with_range(
            Gtk.Orientation.HORIZONTAL, min_val, max_val, step
        )
        scale.set_value(current_val)
        scale.set_draw_value(False)
        scale.set_sensitive(enabled)

        # Create snapping wrapper if snap_increment provided
        if snap_increment:

            def snapping_callback(scale):
                value = scale.get_value()
                snapped_value = round(value / snap_increment) * snap_increment
                if abs(value - snapped_value) > (snap_increment * 0.01):
                    scale.set_value(snapped_value)
                    return
                callback(scale)

            scale.connect("value-changed", snapping_callback)
        else:
            scale.connect("value-changed", callback)

        # Add tick marks
        for mark_val, mark_label in marks:
            scale.add_mark(mark_val, Gtk.PositionType.BOTTOM, mark_label)

        container.append(scale)
        return container, label, scale

    def debounced_save(self, save_function, delay_ms=500):
        """Debounce save operations"""
        if self.timeout_id:
            GLib.source_remove(self.timeout_id)
        self.timeout_id = GLib.timeout_add(delay_ms, save_function)


class PomodoroWidget(BaseControlWidget):
    """Pomodoro timer control widget"""

    def __init__(self, config, window=None):
        super().__init__(
            config, "Pomodoro Timer", "Control the built-in Waybar Pomodoro timer", "üçÖ"
        )
        self.window = window
        self.setup_controls()

    def setup_controls(self):
        """Setup Pomodoro-specific controls"""
        pomodoro_config = self.config.get_pomodoro_config()

        # Duration label (add to title row)
        self.duration_label = Gtk.Label()
        self.duration_label.set_markup(
            f'<span size="11000" alpha="75%">Duration: {pomodoro_config["duration"]} minutes</span>'
        )
        self.duration_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.duration_label)

        # Learn More link (add to title row)
        learn_link = Gtk.Button(label="Learn More")
        learn_link.connect("clicked", self.on_learn_more_clicked)
        learn_link.set_halign(Gtk.Align.END)
        self.title_row.append(learn_link)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(pomodoro_config["enabled"])
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Duration slider (just the slider, no label)
        duration_marks = [(i, f"{i}m") for i in range(5, 65, 5)]
        slider_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        self.duration_scale = Gtk.Scale.new_with_range(
            Gtk.Orientation.HORIZONTAL, 5, 60, 1
        )
        self.duration_scale.set_value(pomodoro_config["duration"])
        self.duration_scale.set_draw_value(False)
        self.duration_scale.set_sensitive(pomodoro_config["enabled"])
        self.duration_scale.connect("value-changed", self.on_duration_changed)

        # Add tick marks
        for mark_val, mark_label in duration_marks:
            self.duration_scale.add_mark(mark_val, Gtk.PositionType.BOTTOM, mark_label)

        slider_box.append(self.duration_scale)
        self.controls_box.append(slider_box)

    def on_toggle(self, switch, param):
        """Handle toggle switch"""
        state = switch.get_active()
        duration = int(self.duration_scale.get_value())

        # Update slider sensitivity
        self.duration_scale.set_sensitive(state)

        # Apply toggle change immediately to waybar
        self.apply_toggle_change(state, duration)

        # Mark changes pending
        self.mark_changes_pending()

    def on_duration_changed(self, scale):
        """Handle duration change with snapping"""
        value = scale.get_value()
        # Snap to nearest 5-minute increment (5, 10, 15, 20, 25, etc.)
        snapped_value = round(value / 5) * 5

        if abs(value - snapped_value) > 0.5:
            scale.set_value(snapped_value)
            return

        duration = int(snapped_value)
        self.duration_label.set_markup(
            f'<span size="11000" alpha="75%">Duration: {duration} minutes</span>'
        )

        # Apply duration change immediately to waybar
        self.apply_duration_change(duration)

        # Mark changes pending
        self.mark_changes_pending()

    def apply_toggle_change(self, enabled, duration):
        """Apply toggle change immediately to waybar"""
        try:
            import subprocess

            # Save config immediately so waybar script can read it
            self.config.set_pomodoro_config(enabled, duration)
            # Refresh waybar pomodoro module
            subprocess.run(["pkill", "-RTMIN+8", "waybar"], check=False)
        except Exception as e:
            print(f"Pomodoro waybar update error: {e}")

    def apply_duration_change(self, duration):
        """Apply duration change immediately to waybar"""
        try:
            import subprocess

            enabled = self.switch.get_active()
            # Save config immediately so waybar script can read it
            self.config.set_pomodoro_config(enabled, duration)
            # Refresh waybar pomodoro module
            subprocess.run(["pkill", "-RTMIN+8", "waybar"], check=False)
        except Exception as e:
            print(f"Pomodoro waybar update error: {e}")

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        enabled = self.switch.get_active()
        duration = int(self.duration_scale.get_value())

        # Save to config (system changes already applied in real-time)
        self.config.set_pomodoro_config(enabled, duration)

    def on_learn_more_clicked(self, button):
        """Handle Learn More button click"""
        self.show_pomodoro_dialog()

    def show_pomodoro_dialog(self):
        """Show enhanced Pomodoro dialog with image"""
        dialog = Gtk.Window()
        dialog.set_title("üçÖ Pomodoro Technique")
        dialog.set_default_size(800, 700)
        dialog.set_resizable(True)
        dialog.set_modal(True)
        dialog.add_css_class("archriot-control-panel")

        if self.window:
            dialog.set_transient_for(self.window.window)

        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=20)
        main_box.set_margin_start(10)  # Reduced margins
        main_box.set_margin_end(10)
        main_box.set_margin_top(10)
        main_box.set_margin_bottom(10)

        # Title
        title_label = Gtk.Label()
        title_label.set_markup(
            '<span size="28000" weight="bold" foreground="#bb9af7" font_family="Paper Mono">üçÖ Pomodoro Technique</span>'
        )
        title_label.set_halign(Gtk.Align.CENTER)
        main_box.append(title_label)

        # Content frame
        content_frame = Gtk.Frame()
        content_frame.set_margin_top(10)

        content_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=15)
        content_box.set_margin_start(10)  # Reduced margins
        content_box.set_margin_end(10)
        content_box.set_margin_top(10)
        content_box.set_margin_bottom(10)

        # Add pomodoro image
        try:
            import os
            import sys

            script_file = (
                sys.argv[0]
                if sys.argv and sys.argv[0]
                else os.path.expanduser(
                    "~/.local/share/archriot/config/bin/archriot-control-panel"
                )
            )
            script_dir = os.path.dirname(os.path.abspath(script_file))
            archriot_dir = os.path.dirname(script_dir)
            image_path = os.path.join(archriot_dir, "config", "images", "pomodoro.png")

            if os.path.exists(image_path):
                # Load the original pixbuf
                pixbuf = GdkPixbuf.Pixbuf.new_from_file(image_path)

                # Create an image widget
                image = Gtk.Image()
                image.set_halign(Gtk.Align.FILL)
                image.set_hexpand(True)  # Allow image to expand horizontally
                image.set_margin_bottom(10)

                # Function to scale pixbuf based on dialog width
                def scale_pixbuf(widget, pixbuf):
                    # Get the dialog's current width, accounting for margins
                    dialog_width = (
                        widget.get_allocated_width()
                        - main_box.get_margin_start()
                        - main_box.get_margin_end()
                        - content_box.get_margin_start()
                        - content_box.get_margin_end()
                        - content_frame.get_margin_start()
                        - content_frame.get_margin_end()
                    )
                    if dialog_width <= 0:
                        dialog_width = 800  # Fallback to default width

                    # Get original dimensions
                    orig_width = pixbuf.get_width()
                    orig_height = pixbuf.get_height()

                    # Calculate scaled height to maintain aspect ratio
                    scale_factor = dialog_width / orig_width
                    new_height = int(orig_height * scale_factor)

                    # Scale the pixbuf
                    scaled_pixbuf = pixbuf.scale_simple(
                        dialog_width, new_height, GdkPixbuf.InterpType.BILINEAR
                    )
                    image.set_from_pixbuf(scaled_pixbuf)

                # Initial scaling
                scale_pixbuf(dialog, pixbuf)

                # Connect to size-allocate to update image on resize
                def on_size_allocate(widget, allocation):
                    scale_pixbuf(widget, pixbuf)

                dialog.connect("size-allocate", on_size_allocate)
                content_box.append(image)
        except Exception as e:
            print(f"Could not load pomodoro image: {e}")

        # Content text
        content = """The Pomodoro Technique is a time management method developed by Francesco Cirillo in the late 1980s. It uses a timer to break work into intervals, traditionally 25 minutes in length, separated by short breaks.

    <b>How it works:</b>

    1. Choose a task to work on
    2. Set the timer for 25 minutes (or your preferred duration)
    3. Work on the task until the timer rings
    4. Take a short 5-minute break
    5. After 4 pomodoros, take a longer 15-30 minute break

    <b>Benefits:</b>

    ‚Ä¢ Improves focus and concentration
    ‚Ä¢ Reduces mental fatigue
    ‚Ä¢ Increases productivity
    ‚Ä¢ Helps overcome procrastination
    ‚Ä¢ Makes time tracking easier
    ‚Ä¢ Reduces burnout

    The technique is named after the tomato-shaped kitchen timer that Cirillo used as a university student.

    ArchRiot's built-in Pomodoro timer integrates directly with your Waybar, making it easy to stay focused while working in your Hyprland environment."""

        content_label = Gtk.Label()
        content_label.set_markup(
            f'<span size="12000" font_family="Paper Mono">{content}</span>'
        )
        content_label.set_wrap(True)
        content_label.set_halign(Gtk.Align.START)
        content_box.append(content_label)

        content_frame.set_child(content_box)
        main_box.append(content_frame)

        # Close button
        close_button = Gtk.Button(label="Close")
        close_button.set_halign(Gtk.Align.CENTER)
        close_button.connect("clicked", lambda x: dialog.close())
        close_button.get_child().set_markup(
            '<span font_family="Paper Mono">Close</span>'
        )
        main_box.append(close_button)

        dialog.set_child(main_box)
        dialog.present()


class BlueLightWidget(BaseControlWidget):
    """Blue light filter control widget"""

    def __init__(self, config, window=None):
        super().__init__(
            config,
            "Blue Light Filter",
            "Control the built-in hyprsunset blue light filter",
            "üí°",
        )
        self.window = window
        self.setup_controls()

    def _read_bluelight_from_hyprland(self):
        """Read current blue light settings directly from hyprland.conf"""
        import re
        from pathlib import Path

        hyprland_config = Path.home() / ".config" / "hypr" / "hyprland.conf"
        enabled = True
        temperature = 3500  # fallback

        if hyprland_config.exists():
            content = hyprland_config.read_text()
            # Check if hyprsunset line is commented out (disabled)
            if re.search(r"^\s*#.*hyprsunset", content, re.MULTILINE):
                enabled = False
            # Extract temperature from active hyprsunset line
            match = re.search(r"exec-once = hyprsunset -t (\d+)", content)
            if match:
                temperature = int(match.group(1))
                enabled = True

        return {"enabled": enabled, "temperature": temperature}

    def setup_controls(self):
        """Setup blue light filter controls"""
        bluelight_config = self._read_bluelight_from_hyprland()

        # Temperature label (add to title row)
        self.temp_label = Gtk.Label()
        self.temp_label.set_markup(
            f'<span size="11000" alpha="75%">Temperature: {bluelight_config["temperature"]}K</span>'
        )
        self.temp_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.temp_label)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(bluelight_config["enabled"])
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Temperature slider (using reusable function)
        temp_marks = [(i, f"{i}K") for i in range(2500, 5500, 500)]
        slider_container, _, self.temp_scale = self.create_slider(
            "",
            2500,
            5000,
            100,
            bluelight_config["temperature"],
            bluelight_config["enabled"],
            temp_marks,
            self.on_temperature_changed,
        )
        self.controls_box.append(slider_container)

    def on_toggle(self, switch, param):
        """Handle toggle switch"""
        state = switch.get_active()
        temperature = int(self.temp_scale.get_value())

        # Update slider sensitivity
        self.temp_scale.set_sensitive(state)

        # Apply change immediately
        if state:
            self.apply_temperature_change(temperature)
        else:
            self.disable_blue_light_filter()

        # Mark changes pending
        self.mark_changes_pending()

    def on_temperature_changed(self, scale):
        """Handle temperature change with snapping"""
        value = scale.get_value()
        # Snap to nearest 500K increment
        snapped_value = round(value / 500) * 500

        if abs(value - snapped_value) > 50:
            scale.set_value(snapped_value)
            return

        temperature = int(snapped_value)
        self.temp_label.set_markup(
            f'<span size="11000" alpha="75%">Temperature: {temperature}K</span>'
        )

        # Apply temperature change immediately
        if self.switch.get_active():
            self.apply_temperature_change(temperature)

        # Mark changes pending
        self.mark_changes_pending()

    def apply_temperature_change(self, temperature):
        """Apply temperature change immediately to system and update config"""
        try:
            import subprocess
            import os
            import time
            import re
            from pathlib import Path

            # Kill any existing hyprsunset processes (ensure only one instance)
            subprocess.run(["pkill", "-f", "hyprsunset"], check=False)
            # Wait a moment for processes to fully terminate
            time.sleep(0.1)
            # Start hyprsunset with new temperature as detached process
            subprocess.Popen(
                ["hyprsunset", "-t", str(temperature)],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                preexec_fn=os.setsid,
            )

            # Update Hyprland config to make change persistent
            hyprland_config = Path.home() / ".config" / "hypr" / "hyprland.conf"
            if hyprland_config.exists():
                content = hyprland_config.read_text()
                # Replace hyprsunset line with new temperature
                content = re.sub(
                    r"exec-once = hyprsunset -t \d+",
                    f"exec-once = hyprsunset -t {temperature}",
                    content,
                )
                hyprland_config.write_text(content)

            # Save to external config file for persistence
            self.save_bluelight_setting(True, temperature)
        except Exception as e:
            print(f"Blue light filter error: {e}")  # Debug output

    def disable_blue_light_filter(self):
        """Disable blue light filter immediately and update config"""
        try:
            import subprocess
            import re
            from pathlib import Path

            # Kill any existing hyprsunset processes (ensure complete shutdown)
            subprocess.run(["pkill", "-f", "hyprsunset"], check=False)
            # Wait a moment for processes to fully terminate
            time.sleep(0.1)

            # Comment out hyprsunset line in Hyprland config
            hyprland_config = Path.home() / ".config" / "hypr" / "hyprland.conf"
            if hyprland_config.exists():
                content = hyprland_config.read_text()
                # Comment out the hyprsunset line
                content = re.sub(
                    r"exec-once = hyprsunset -t \d+",
                    "# exec-once = hyprsunset -t 3500  # Disabled via Control Panel",
                    content,
                )
                hyprland_config.write_text(content)

            # Save to external config file for persistence
            self.save_bluelight_setting(False, 3500)
        except Exception as e:
            print(f"Blue light filter disable error: {e}")  # Debug output

    def save_bluelight_setting(self, enabled, temperature):
        """Save blue light setting to external config file for upgrade persistence"""
        try:
            import configparser
            import os
            from pathlib import Path

            config_file = Path.home() / ".config" / "archriot" / "archriot.conf"
            config = configparser.ConfigParser()

            # Read existing config if it exists
            if config_file.exists():
                config.read(config_file)

            # Ensure bluelight section exists
            if not config.has_section("bluelight"):
                config.add_section("bluelight")

            # Update bluelight settings
            config.set("bluelight", "enabled", str(enabled).lower())
            config.set("bluelight", "temperature", str(temperature))

            # Write back to file
            os.makedirs(config_file.parent, exist_ok=True)
            with open(config_file, "w") as f:
                config.write(f)

        except Exception as e:
            print(f"Failed to save bluelight setting: {e}")

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        # All changes are already applied in real-time to system configs
        # No separate config file needed
        pass


class MullvadWidget(BaseControlWidget):
    """Mullvad VPN control widget"""

    def __init__(self, config, window=None):
        super().__init__(
            config, "Mullvad VPN", "Manage VPN connection and account settings", "üõ°Ô∏è"
        )
        self.window = window
        self.setup_controls()

    def setup_controls(self):
        """Setup Mullvad VPN controls"""
        # Read directly from system - no config dependency
        current_account = self.get_current_mullvad_account()
        current_auto_connect = self.get_current_auto_connect_status()

        # Use actual system values
        account_number = current_account or ""
        actual_auto_connect = (
            current_auto_connect if current_auto_connect is not None else False
        )

        # Auto-connect label (add to title row)
        self.auto_connect_label = Gtk.Label()
        self.auto_connect_label.set_markup(
            f'<span size="11000" alpha="75%">Auto-connect: {"On" if actual_auto_connect else "Off"}</span>'
        )
        self.auto_connect_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.auto_connect_label)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(actual_auto_connect)
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Account number entry
        account_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        account_label = Gtk.Label(label="Account Number:")
        account_label.set_halign(Gtk.Align.START)

        self.account_entry = Gtk.Entry()
        self.account_entry.set_placeholder_text("1234 5678 9012 3456")

        # Show account number privately (hidden by default)
        if account_number:
            self.account_entry.set_visibility(False)  # Hide by default
            self.account_entry.set_text(self.format_account_number(account_number))
            self.is_account_visible = False
        else:
            self.account_entry.set_text("")
            self.is_account_visible = True

        self.account_entry.set_max_length(19)
        self.account_entry.set_width_chars(25)
        self.account_entry.connect("changed", self.on_account_changed)
        self.account_entry.connect("activate", self.on_account_activate)

        account_box.append(account_label)
        account_box.append(self.account_entry)

        # Eye toggle button for show/hide
        self.eye_button = Gtk.Button()
        self.eye_button.set_size_request(40, -1)  # Set minimum width
        self.eye_button.set_halign(Gtk.Align.CENTER)
        self.update_eye_button()
        self.eye_button.connect("clicked", self.on_eye_toggle)
        account_box.append(self.eye_button)

        # Spacer to push button right
        spacer = Gtk.Box()
        spacer.set_hexpand(True)
        account_box.append(spacer)

        # Get Mullvad VPN button (same line, right-justified)
        link_button = Gtk.Button(label="Get Mullvad VPN")
        link_button.connect("clicked", self.on_get_mullvad_clicked)
        link_button.set_halign(Gtk.Align.END)
        account_box.append(link_button)

        self.controls_box.append(account_box)

    def on_toggle(self, switch, param):
        """Handle auto-connect toggle switch"""
        state = switch.get_active()
        account_number = self.account_entry.get_text()

        # Update label
        self.auto_connect_label.set_markup(
            f'<span size="11000" alpha="75%">Auto-connect: {"On" if state else "Off"}</span>'
        )

        # Apply changes immediately to system
        self.apply_toggle_change(state, account_number)

        # Mark changes pending
        self.mark_changes_pending()

    def format_account_number(self, account_number):
        """Format account number with spaces every 4 digits"""
        # Remove any existing spaces
        clean = account_number.replace(" ", "")
        # Add spaces every 4 digits
        formatted = " ".join(clean[i : i + 4] for i in range(0, len(clean), 4))
        return formatted

    def on_account_changed(self, entry):
        """Handle account number input with auto-formatting"""
        text = entry.get_text()
        cursor_pos = entry.get_position()

        # Only allow digits and spaces
        filtered = "".join(c for c in text if c.isdigit() or c == " ")

        # Remove all spaces and re-format
        digits_only = "".join(c for c in filtered if c.isdigit())

        # Limit to 16 digits
        if len(digits_only) > 16:
            digits_only = digits_only[:16]

        # Format with spaces
        formatted = self.format_account_number(digits_only)

        # Update field if changed
        if formatted != text:
            # Calculate new cursor position accounting for added spaces
            digits_before_cursor = len(
                "".join(c for c in text[:cursor_pos] if c.isdigit())
            )
            spaces_before_cursor = (
                (digits_before_cursor - 1) // 4 if digits_before_cursor > 0 else 0
            )
            new_pos = digits_before_cursor + spaces_before_cursor

            entry.set_text(formatted)
            entry.set_position(min(new_pos, len(formatted)))

    def on_account_activate(self, entry):
        """Handle account number validation when user presses Enter"""
        text = entry.get_text()
        clean_text = text.replace(" ", "")

        # Apply account change immediately
        self.apply_account_change(clean_text)

        # Mark changes pending
        self.mark_changes_pending()

    def get_current_mullvad_account(self):
        """Get current Mullvad account number from system"""
        try:
            import subprocess

            result = subprocess.run(
                ["mullvad", "account", "get"], capture_output=True, text=True
            )
            if result.returncode == 0:
                for line in result.stdout.split("\n"):
                    if "Mullvad account:" in line:
                        account = line.split(":")[1].strip()
                        return account
        except Exception:
            pass
        return None

    def get_current_auto_connect_status(self):
        """Get current auto-connect status from Mullvad"""
        try:
            import subprocess

            result = subprocess.run(
                ["mullvad", "auto-connect", "get"], capture_output=True, text=True
            )
            if result.returncode == 0:
                return "on" in result.stdout.lower()
        except Exception:
            pass
        return None

    def update_eye_button(self):
        """Update eye button appearance based on visibility state"""
        if hasattr(self, "is_account_visible") and self.is_account_visible:
            self.eye_button.set_label("üëÅÔ∏è")  # Open eye = visible
        else:
            self.eye_button.set_label("üîí")  # Lock = hidden

    def on_eye_toggle(self, button):
        """Toggle account number visibility"""
        self.is_account_visible = not self.is_account_visible
        self.account_entry.set_visibility(self.is_account_visible)
        self.update_eye_button()

    def apply_toggle_change(self, enabled, account_number):
        """Apply auto-connect toggle change immediately"""
        try:
            import subprocess
            from pathlib import Path

            # Set auto-connect
            if enabled:
                subprocess.run(["mullvad", "auto-connect", "set", "on"], check=False)

                # Update Hyprland config to start Mullvad GUI via ArchRiot launcher
                hyprland_config = Path.home() / ".config" / "hypr" / "hyprland.conf"
                if hyprland_config.exists():
                    content = hyprland_config.read_text()
                    launch_line = "exec-once = $HOME/.local/share/archriot/install/archriot --mullvad-startup"
                    if launch_line not in content:
                        # Add Mullvad launcher to exec-once
                        content += f"\n{launch_line}\n"
                        hyprland_config.write_text(content)
            else:
                subprocess.run(["mullvad", "auto-connect", "set", "off"], check=False)

                # Remove ArchRiot Mullvad launcher from Hyprland config
                hyprland_config = Path.home() / ".config" / "hypr" / "hyprland.conf"
                if hyprland_config.exists():
                    content = hyprland_config.read_text()
                    launch_line = "exec-once = $HOME/.local/share/archriot/install/archriot --mullvad-startup"
                    content = content.replace(launch_line + "\n", "")
                    content = content.replace("\n" + launch_line, "")
                    hyprland_config.write_text(content)
        except Exception as e:
            print(f"Mullvad toggle error: {e}")

    def apply_account_change(self, account_number):
        """Apply account login immediately"""
        try:
            import subprocess

            if account_number and len(account_number) >= 10:
                subprocess.run(
                    ["mullvad", "account", "login", account_number], check=False
                )
        except Exception as e:
            print(f"Mullvad account error: {e}")

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        # All changes are already applied in real-time to mullvad system
        # No separate config file needed - mullvad service is the source of truth
        pass

    def on_get_mullvad_clicked(self, button):
        """Open Mullvad VPN website"""
        import subprocess

        subprocess.Popen(["xdg-open", "https://mullvad.net"])


class AudioWidget(BaseControlWidget):
    """Audio system control widget"""

    def __init__(self, config, window=None):
        super().__init__(config, "Audio", "PipeWire/PulseAudio configuration", "üîä")
        self.window = window
        self.setup_controls()

    def setup_controls(self):
        """Setup audio system controls"""
        # Get current audio system status
        current_status = self.get_audio_status()

        # Audio enabled label (add to title row)
        self.audio_label = Gtk.Label()
        self.audio_label.set_markup(
            f'<span size="11000" alpha="75%">Audio: {"On" if current_status else "Off"}</span>'
        )
        self.audio_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.audio_label)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(current_status)
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

    def on_toggle(self, switch, param):
        """Handle audio system toggle switch"""
        state = switch.get_active()

        # Update label
        self.audio_label.set_markup(
            f'<span size="11000" alpha="75%">Audio: {"On" if state else "Off"}</span>'
        )

        # Apply audio system change immediately
        self.apply_audio_change(state)

        # Mark changes pending
        self.mark_changes_pending()

    def get_audio_status(self):
        """Get current audio mute status"""
        try:
            import subprocess

            # Check if audio is muted using pactl
            result = subprocess.run(
                ["pactl", "get-sink-mute", "@DEFAULT_SINK@"],
                capture_output=True,
                text=True,
            )
            if result.returncode == 0:
                return "no" in result.stdout.lower()  # 'no' means not muted = audio on
            return True  # Default to on if we can't detect
        except Exception:
            return True  # Default to on if we can't detect

    def apply_audio_change(self, enabled):
        """Apply audio mute/unmute change immediately"""
        try:
            import subprocess

            if enabled:
                # Unmute audio
                subprocess.run(
                    ["pactl", "set-sink-mute", "@DEFAULT_SINK@", "0"], check=False
                )
            else:
                # Mute audio
                subprocess.run(
                    ["pactl", "set-sink-mute", "@DEFAULT_SINK@", "1"], check=False
                )
        except Exception as e:
            print(f"Audio mute error: {e}")

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        # Audio changes are already applied in real-time
        pass


class CameraWidget(BaseControlWidget):
    """Camera system control widget"""

    def __init__(self, config, window=None):
        super().__init__(
            config, "Camera", "Camera control and resolution settings", "üì∑"
        )
        self.window = window
        self.setup_controls()

    def setup_controls(self):
        """Setup camera controls"""
        # Get current camera status and resolution
        current_status = self.get_camera_status()
        current_resolution = self.get_camera_resolution()

        # Resolution label (add to title row)
        self.resolution_label = Gtk.Label()
        self.resolution_label.set_markup(
            f'<span size="11000" alpha="75%">Resolution: {current_resolution}</span>'
        )
        self.resolution_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.resolution_label)

        # Test Camera button (add to title row)
        test_button = Gtk.Button(label="Test Camera")
        test_button.connect("clicked", self.on_test_camera)
        test_button.set_sensitive(current_status)
        self.test_button = test_button
        self.title_row.append(test_button)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(current_status)
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Resolution slider
        self.available_resolutions = [
            "640x480",
            "960x540",
            "960x720",
            "1280x720",
            "1920x1080",
        ]
        resolution_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        self.resolution_scale = Gtk.Scale.new_with_range(
            Gtk.Orientation.HORIZONTAL, 0, len(self.available_resolutions) - 1, 1
        )

        # Set to current resolution
        current_index = 0
        for i, res in enumerate(self.available_resolutions):
            if res == current_resolution:
                current_index = i
                break

        self.resolution_scale.set_value(current_index)
        self.resolution_scale.set_draw_value(False)
        self.resolution_scale.set_sensitive(current_status)
        self.resolution_scale.connect("value-changed", self.on_resolution_changed)

        # Add margins to prevent text cutoff
        self.resolution_scale.set_margin_start(40)
        self.resolution_scale.set_margin_end(40)

        # Add tick marks
        for i, res in enumerate(self.available_resolutions):
            self.resolution_scale.add_mark(i, Gtk.PositionType.BOTTOM, res)

        resolution_box.append(self.resolution_scale)
        self.controls_box.append(resolution_box)

    def on_toggle(self, switch, param):
        """Handle camera toggle switch"""
        state = switch.get_active()

        # Update slider and test button sensitivity
        self.resolution_scale.set_sensitive(state)
        self.test_button.set_sensitive(state)

        # Apply camera change immediately
        self.apply_camera_change(state)

        # Mark changes pending
        self.mark_changes_pending()

    def on_resolution_changed(self, scale):
        """Handle resolution change with snapping"""
        value = scale.get_value()
        # Snap to nearest resolution index
        snapped_value = round(value)

        if abs(value - snapped_value) > 0.1:
            scale.set_value(snapped_value)
            return

        # Apply resolution change immediately
        index = int(snapped_value)
        if 0 <= index < len(self.available_resolutions):
            resolution = self.available_resolutions[index]
            self.resolution_label.set_markup(
                f'<span size="11000" alpha="75%">Resolution: {resolution}</span>'
            )
            self.apply_resolution_change(resolution)

        # Mark changes pending
        self.mark_changes_pending()

    def on_test_camera(self, button):
        """Handle test camera button click"""
        self.show_camera_preview()

    def get_camera_status(self):
        """Get current camera device status"""
        try:
            import os

            # Check if camera devices exist and are accessible
            camera_devices = ["/dev/video0", "/dev/video1"]
            for device in camera_devices:
                if os.path.exists(device) and os.access(device, os.R_OK):
                    return True
            return False
        except Exception:
            return False

    def get_camera_resolution(self):
        """Get current camera resolution"""
        try:
            import subprocess

            result = subprocess.run(
                ["v4l2-ctl", "--get-fmt-video", "-d", "/dev/video0"],
                capture_output=True,
                text=True,
            )
            if result.returncode == 0:
                for line in result.stdout.split("\n"):
                    if "Width/Height" in line:
                        # Extract resolution from "Width/Height      : 960/720"
                        parts = line.split(":")[1].strip().split("/")
                        if len(parts) == 2:
                            width = parts[0].strip()
                            height = parts[1].strip()
                            return f"{width}x{height}"
            return "960x720"  # Default to current actual resolution
        except Exception:
            return "960x720"  # Default to current actual resolution

    def apply_camera_change(self, enabled):
        """Apply camera access change immediately"""
        try:
            import subprocess
            import os

            camera_devices = ["/dev/video0", "/dev/video1"]

            if enabled:
                # Enable camera access by setting proper permissions
                for device in camera_devices:
                    if os.path.exists(device):
                        subprocess.run(["sudo", "chmod", "666", device], check=False)
            else:
                # Disable camera access by removing permissions
                for device in camera_devices:
                    if os.path.exists(device):
                        subprocess.run(["sudo", "chmod", "000", device], check=False)
        except Exception as e:
            print(f"Camera access error: {e}")

    def apply_resolution_change(self, resolution):
        """Apply camera resolution change immediately"""
        try:
            import subprocess

            width, height = resolution.split("x")
            # Set camera resolution using v4l2-ctl
            subprocess.run(
                [
                    "v4l2-ctl",
                    "-d",
                    "/dev/video0",
                    "--set-fmt-video=width={},height={},pixelformat=MJPG".format(
                        width, height
                    ),
                ],
                check=False,
            )
        except Exception as e:
            print(f"Camera resolution error: {e}")

    def show_camera_preview(self):
        """Show simple GTK camera preview dialog"""
        try:
            import cv2
            import threading
            import time
            from gi.repository import GLib
            import numpy as np

            # Create camera preview dialog
            dialog = Gtk.Window()
            dialog.set_default_size(700, 600)
            dialog.set_modal(True)
            dialog.set_transient_for(self.window.window if self.window else None)
            dialog.add_css_class("archriot-control-panel")

            main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=20)
            main_box.set_margin_start(30)
            main_box.set_margin_end(30)
            main_box.set_margin_top(15)
            main_box.set_margin_bottom(20)

            # Header
            title_label = Gtk.Label()
            title_label.set_markup(
                '<span size="28000" weight="bold" foreground="#bb9af7">üì∑ Camera Video Test</span>'
            )
            title_label.set_halign(Gtk.Align.CENTER)
            main_box.append(title_label)

            # Content frame
            content_frame = Gtk.Frame()
            content_frame.set_margin_top(10)
            content_frame.add_css_class("archriot-control-panel")
            content_frame.set_vexpand(True)

            # Video display - fill the content frame completely
            self.camera_image = Gtk.Image()
            self.camera_image.set_hexpand(True)
            self.camera_image.set_vexpand(True)
            self.camera_image.set_halign(Gtk.Align.FILL)
            self.camera_image.set_valign(Gtk.Align.FILL)

            content_frame.set_child(self.camera_image)
            main_box.append(content_frame)

            # Close button
            close_button = Gtk.Button(label="Close")
            close_button.set_halign(Gtk.Align.CENTER)
            close_button.connect(
                "clicked", lambda x: self.stop_camera_and_close(dialog)
            )
            main_box.append(close_button)

            dialog.set_child(main_box)
            dialog.present()

            # Start camera feed
            self.camera_running = True
            self.camera_thread = threading.Thread(target=self.camera_feed_loop)
            self.camera_thread.daemon = True
            self.camera_thread.start()

        except ImportError:
            # Fallback if OpenCV not available
            content = "Camera preview requires OpenCV (python-opencv). Please install it:\n\nsudo pacman -S python-opencv"
            fallback_dialog = ArchRiotDialog(
                "üì∑ Camera Preview",
                content,
                self.window.window if self.window else None,
            )
            fallback_dialog.show()
        except Exception as e:
            print(f"Camera preview error: {e}")

    def stop_camera_and_close(self, dialog):
        """Stop camera and close dialog"""
        self.camera_running = False
        if hasattr(self, "cap"):
            self.cap.release()
        dialog.close()

    def camera_feed_loop(self):
        """Camera feed loop running in background thread"""
        try:
            import cv2

            self.cap = cv2.VideoCapture(0)
            self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
            self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

            while self.camera_running:
                ret, frame = self.cap.read()
                if ret:
                    # Convert BGR to RGB
                    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

                    # Convert to GdkPixbuf
                    height, width, channels = frame_rgb.shape
                    pixbuf = GdkPixbuf.Pixbuf.new_from_data(
                        frame_rgb.tobytes(),
                        GdkPixbuf.Colorspace.RGB,
                        False,
                        8,
                        width,
                        height,
                        width * channels,
                    )

                    # Update image on main thread
                    GLib.idle_add(self.update_camera_image, pixbuf)

                time.sleep(1 / 30)  # 30 FPS

            self.cap.release()
        except Exception as e:
            print(f"Camera feed error: {e}")

    def update_camera_image(self, pixbuf):
        """Update camera image on main thread"""
        if hasattr(self, "camera_image"):
            self.camera_image.set_from_pixbuf(pixbuf)
        return False

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        # Camera changes are already applied in real-time
        pass


class DisplayWidget(BaseControlWidget):
    """Display settings control widget"""

    def __init__(self, config, window=None):
        super().__init__(
            config, "Display Settings", "Monitor configuration and scaling", "üñ•Ô∏è"
        )
        self.window = window
        self.setup_controls()

    def get_available_resolutions(self):
        """Get available monitor resolutions with smart aspect ratio logic"""
        try:
            import subprocess
            import os
            from fractions import Fraction

            # Try hyprctl first
            result = subprocess.run(
                ["hyprctl", "monitors"], capture_output=True, text=True, timeout=5
            )
            current_resolution = "1920x1080"

            if result.returncode == 0:
                for line in result.stdout.split("\n"):
                    # Get current resolution from tab-indented line like "\t2560x1440@60.00100 at 0x0"
                    if "@" in line and "x" in line and not "availableModes:" in line:
                        if line.strip() and line.startswith("\t") and " at " in line:
                            try:
                                resolution_part = line.strip().split("@")[0]
                                if "x" in resolution_part:
                                    current_resolution = resolution_part
                            except (ValueError, IndexError):
                                pass

            # Generate smart resolutions based on current resolution's aspect ratio
            try:
                width, height = map(int, current_resolution.split("x"))
                aspect_ratio = Fraction(width, height)

                # Common resolution sets by aspect ratio
                resolution_sets = {
                    Fraction(16, 9): [
                        "3840x2160",
                        "2560x1440",
                        "1920x1080",
                        "1600x900",
                        "1366x768",
                        "1280x720",
                    ],
                    Fraction(16, 10): [
                        "3840x2400",
                        "2560x1600",
                        "1920x1200",
                        "1680x1050",
                        "1440x900",
                        "1280x800",
                    ],
                    Fraction(4, 3): [
                        "2048x1536",
                        "1600x1200",
                        "1400x1050",
                        "1024x768",
                        "800x600",
                    ],
                    Fraction(21, 9): ["3440x1440", "2560x1080"],  # Ultrawide
                    Fraction(32, 9): ["3840x1080"],  # Super ultrawide
                }

                # Find the closest matching aspect ratio
                best_match = min(
                    resolution_sets.keys(),
                    key=lambda ratio: abs(float(ratio) - float(aspect_ratio)),
                )

                # Get resolutions for this aspect ratio
                smart_resolutions = resolution_sets[best_match]

                # Filter to only include resolutions <= current resolution
                max_pixels = width * height
                filtered_resolutions = []
                for res in smart_resolutions:
                    res_width, res_height = map(int, res.split("x"))
                    if res_width * res_height <= max_pixels:
                        filtered_resolutions.append(res)

                # Ensure current resolution is included
                if current_resolution not in filtered_resolutions:
                    filtered_resolutions.insert(0, current_resolution)

                # Remove duplicates and limit to 5 options
                seen = set()
                unique_resolutions = []
                for res in filtered_resolutions:
                    if res not in seen:
                        seen.add(res)
                        unique_resolutions.append(res)

                return unique_resolutions[:5], current_resolution

            except (ValueError, IndexError):
                # Fallback if aspect ratio calculation fails
                pass

            # Final fallback - 16:9 resolutions
            return [
                "2560x1440",
                "1920x1080",
                "1600x900",
                "1366x768",
                "1280x720",
            ], current_resolution

        except Exception as e:
            return [
                "1920x1080",
                "1600x900",
                "1366x768",
                "1280x720",
                "1024x768",
            ], "1920x1080"

    def get_current_scaling(self):
        """Get current monitor scaling from hyprctl (focused monitor if present)"""
        try:
            import subprocess, json

            result = subprocess.run(
                ["hyprctl", "-j", "monitors"], capture_output=True, text=True, timeout=5
            )
            if result.returncode != 0 or not result.stdout.strip():
                return 100

            mons = json.loads(result.stdout)
            if isinstance(mons, list) and mons:
                focused = next((m for m in mons if m.get("focused")), None)
                m = focused or mons[0]
                scale = m.get("scale")
                if isinstance(scale, (int, float)) and scale > 0:
                    return int(scale * 100 + 0.5)

            return 100
        except Exception:
            return 100

    def setup_controls(self):
        """Setup display settings controls"""
        # Read directly from system - no config dependency
        current_resolution = "1920x1080"
        current_scaling = 100
        enabled = True  # Display is always enabled if system is running

        # Get available resolutions and current resolution
        try:
            self.available_resolutions, current_resolution = (
                self.get_available_resolutions()
            )
        except Exception as e:
            self.available_resolutions, current_resolution = (
                ["1920x1200", "1920x1080", "1680x1050", "1600x1200", "1440x900"],
                "1920x1080",
            )

        # Get actual current scaling from system
        current_scaling = self.get_current_scaling()

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(enabled)
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Resolution slider
        resolution_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        # Create evenly spaced resolution scale (0 to 4 positions)

        # Ensure we have at least 2 resolutions for a valid slider range
        if len(self.available_resolutions) < 2:
            self.available_resolutions = [
                "1920x1200",
                "1920x1080",
                "1680x1050",
                "1600x1200",
                "1440x900",
            ]
            current_resolution = "1920x1080"

        max_range = max(
            1, len(self.available_resolutions) - 1
        )  # Ensure max is at least 1

        try:
            self.resolution_scale = Gtk.Scale.new_with_range(
                Gtk.Orientation.HORIZONTAL, 0, max_range, 1
            )
        except Exception as e:
            print(f"Failed to create resolution_scale: {e}")
            raise

        # Set to current resolution index
        current_index = 0
        for i, res in enumerate(self.available_resolutions):
            if res == current_resolution:
                current_index = i
                break

        try:
            self.resolution_scale.set_value(current_index)
        except Exception as e:
            print(f"Failed to set resolution_scale value: {e}")
            raise

        try:
            self.resolution_scale.set_draw_value(False)

            self.resolution_scale.set_sensitive(enabled)

            self.resolution_scale.set_margin_start(50)

            self.resolution_scale.set_margin_end(50)

            self.resolution_scale.connect("value-changed", self.on_resolution_changed)

        except Exception as e:
            raise

        # Add tick marks with actual available resolutions
        for i, resolution in enumerate(self.available_resolutions):
            # Convert "1920x1080" to "1920√ó1080" for display
            display_res = resolution.replace("x", "√ó")
            self.resolution_scale.add_mark(i, Gtk.PositionType.BOTTOM, display_res)

        resolution_box.append(self.resolution_scale)
        self.controls_box.append(resolution_box)

        # Scaling slider - all valid Hyprland scaling factors
        scaling_values = [
            100,
            107,
            120,
            125,
            150,
            175,
            200,
        ]  # 1.0, 1.066, 1.2, 1.25, 1.5, 1.75, 2.0
        scaling_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        self.scaling_scale = Gtk.Scale.new_with_range(
            Gtk.Orientation.HORIZONTAL, 100, 200, 1
        )
        self.scaling_scale.set_value(current_scaling)
        self.scaling_scale.set_draw_value(False)
        self.scaling_scale.set_sensitive(enabled)
        self.scaling_scale.connect("value-changed", self.on_scaling_changed)

        # Add scaling tick marks with proper labels
        scaling_labels = ["100%", "107%", "120%", "125%", "150%", "175%", "200%"]
        for i, scaling in enumerate(scaling_values):
            self.scaling_scale.add_mark(
                scaling, Gtk.PositionType.BOTTOM, scaling_labels[i]
            )

        scaling_box.append(self.scaling_scale)
        self.controls_box.append(scaling_box)

    def snap_to_nearest(self, value, valid_values):
        """Snap value to nearest valid option"""
        return min(valid_values, key=lambda x: abs(x - value))

    def on_toggle(self, switch, param):
        """Handle toggle switch"""
        state = switch.get_active()

        # Update slider sensitivity
        self.resolution_scale.set_sensitive(state)
        self.scaling_scale.set_sensitive(state)

        # Mark changes pending
        self.mark_changes_pending()

    def on_resolution_changed(self, scale):
        """Handle resolution change with snapping"""
        value = scale.get_value()
        # Snap to nearest resolution index
        snapped_value = round(value)

        if abs(value - snapped_value) > 0.5:
            scale.set_value(snapped_value)
            return

        # Apply resolution change immediately
        index = int(snapped_value)
        if 0 <= index < len(self.available_resolutions):
            resolution = self.available_resolutions[index]
            self.apply_resolution_change(resolution)

        # Mark changes pending
        self.mark_changes_pending()

    def on_scaling_changed(self, scale):
        """Handle scaling change with snapping"""
        value = scale.get_value()
        snapped_value = self.snap_to_nearest(value, [100, 107, 120, 125, 150, 175, 200])

        if abs(value - snapped_value) > 0.5:
            scale.set_value(snapped_value)
            return

        # Apply scaling change immediately
        self.apply_scaling_change(int(snapped_value))

        # Mark changes pending
        self.mark_changes_pending()

    def apply_resolution_change(self, resolution):
        """Apply resolution change immediately to system, preserving current scale and persist to kanshi"""
        try:
            import subprocess, json

            # Read monitors (JSON) and pick focused monitor reliably
            r = subprocess.run(
                ["hyprctl", "-j", "monitors"], capture_output=True, text=True, timeout=5
            )
            if r.returncode != 0 or not r.stdout.strip():
                return

            mons = json.loads(r.stdout)
            if not isinstance(mons, list) or not mons:
                return

            focused = next((m for m in mons if m.get("focused")), None)
            mon = focused or mons[0]
            monitor_name = mon.get("name") or mon.get("id")
            if not monitor_name:
                return

            # Preserve current scale; use preferred apply path for position
            scale = mon.get("scale") or 1.0
            try:
                scale = float(scale)
            except Exception:
                scale = 1.0

            # Try to apply requested resolution while preserving current scale
            result = subprocess.run(
                [
                    "hyprctl",
                    "keyword",
                    "monitor",
                    f"{monitor_name},{resolution},auto,{scale}",
                ],
                capture_output=True,
                text=True,
            )
            if result.returncode != 0:
                # Fallback to preferred mode with the same scale and notify for visibility
                subprocess.run(
                    [
                        "hyprctl",
                        "keyword",
                        "monitor",
                        f"{monitor_name},preferred,auto,{scale}",
                    ],
                    check=False,
                )
                subprocess.run(
                    [
                        "sh",
                        "-lc",
                        f"command -v notify-send >/dev/null 2>&1 && notify-send 'Display resolution' 'Applied scale {scale} with preferred mode (fallback). Unable to set {resolution}.' || true",
                    ],
                    check=False,
                )

            # Persist resolution to kanshi: replace existing 'mode' or append if missing
            try:
                from pathlib import Path as _Path
                import re as _re
                kanshi_path = _Path.home() / ".config" / "kanshi" / "config"
                if kanshi_path.exists():
                    content = kanshi_path.read_text()
                    # Replace existing mode value for this output
                    pattern_mode = _re.compile(rf"(^\s*output\s+{_re.escape(monitor_name)}\b[^\n]*?\bmode\s+)(\S+)", _re.MULTILINE)
                    new_content, n1 = pattern_mode.subn(rf"\g<1>{resolution}", content)
                    if n1 == 0:
                        # Append mode if it's missing on the output line
                        pattern_no_mode = _re.compile(rf"(^\s*output\s+{_re.escape(monitor_name)}\b(?![^\n]*\bmode\b)[^\n]*)$", _re.MULTILINE)
                        def _append_mode(m):
                            return m.group(1) + f" mode {resolution}"
                        new_content2, n2 = pattern_no_mode.subn(_append_mode, content)
                        if n2 > 0 and new_content2 != content:
                            kanshi_path.write_text(new_content2)
                    else:
                        if new_content != content:
                            kanshi_path.write_text(new_content)
            except Exception:
                pass
        except Exception as e:
            print(f"Resolution change error: {e}")

    def apply_scaling_change(self, scaling):
        """Apply scaling change immediately to system"""
        try:
            import subprocess, json, re
            from pathlib import Path

            scale_factor = scaling / 100.0

            # Read monitors (JSON) and pick focused monitor reliably
            r = subprocess.run(
                ["hyprctl", "-j", "monitors"], capture_output=True, text=True, timeout=5
            )
            if r.returncode != 0 or not r.stdout.strip():
                return

            mons = json.loads(r.stdout)
            if not isinstance(mons, list) or not mons:
                return

            focused = next((m for m in mons if m.get("focused")), None)
            mon = focused or mons[0]
            monitor_name = mon.get("name") or mon.get("id")
            if not monitor_name:
                return

            # Apply scaling using preferred,auto,<scale> to avoid brittle resolution parsing
            # Apply scaling using preferred,auto,<scale>; verify and fall back if needed
            result = subprocess.run(
                [
                    "hyprctl",
                    "keyword",
                    "monitor",
                    f"{monitor_name},preferred,auto,{scale_factor}",
                ],
                capture_output=True,
                text=True,
            )

            if result.returncode != 0:
                # Fallback: attempt explicit current resolution if JSON provided width/height
                curr_w = mon.get("width")
                curr_h = mon.get("height")
                if (
                    isinstance(curr_w, int)
                    and isinstance(curr_h, int)
                    and curr_w > 0
                    and curr_h > 0
                ):
                    subprocess.run(
                        [
                            "hyprctl",
                            "keyword",
                            "monitor",
                            f"{monitor_name},{curr_w}x{curr_h},auto,{scale_factor}",
                        ],
                        check=False,
                    )
                else:
                    # Last resort: notify that scaling failed for visibility
                    subprocess.run(
                        [
                            "sh",
                            "-lc",
                            f"command -v notify-send >/dev/null 2>&1 && notify-send 'Display scaling' 'Failed to apply scale to {monitor_name}' || true",
                        ],
                        check=False,
                    )

            # Verify the scale actually changed; notify if not
            vr = subprocess.run(
                ["hyprctl", "-j", "monitors"], capture_output=True, text=True
            )
            if vr.returncode == 0 and vr.stdout.strip():
                try:
                    vmons = json.loads(vr.stdout)
                    target = None
                    if isinstance(vmons, list):
                        for m2 in vmons:
                            if (m2.get("name") or m2.get("id")) == monitor_name:
                                target = m2
                                break
                    if target:
                        cur = target.get("scale")
                        if (
                            isinstance(cur, (int, float))
                            and abs(cur - scale_factor) > 0.01
                        ):
                            subprocess.run(
                                [
                                    "sh",
                                    "-lc",
                                    f"command -v notify-send >/dev/null 2>&1 && notify-send 'Display scaling' 'Requested {scale_factor:.2f} but current is {cur:.2f}. Your compositor or profile may be overriding scale.' || true",
                                ],
                                check=False,
                            )
                except Exception:
                    pass

            # Persist scale to kanshi: replace existing 'scale' or append if missing
            try:
                from pathlib import Path as _Path
                import re as _re
                kanshi_path = _Path.home() / ".config" / "kanshi" / "config"
                if kanshi_path.exists():
                    content = kanshi_path.read_text()
                    # Replace existing scale value for this output
                    pattern_scale = _re.compile(rf"(^\s*output\s+{_re.escape(monitor_name)}\b[^\n]*?\bscale\s+)(\d+(\.\d+)?)", _re.MULTILINE)
                    new_content, n1 = pattern_scale.subn(rf"\g<1>{scale_factor}", content)
                    if n1 == 0:
                        # Append scale if it's missing on the output line
                        pattern_no_scale = _re.compile(rf"(^\s*output\s+{_re.escape(monitor_name)}\b(?![^\n]*\bscale\b)[^\n]*)$", _re.MULTILINE)
                        def _append_scale(m):
                            return m.group(1) + f" scale {scale_factor}"
                        new_content2, n2 = pattern_no_scale.subn(_append_scale, content)
                        if n2 > 0 and new_content2 != content:
                            kanshi_path.write_text(new_content2)
                    else:
                        if new_content != content:
                            kanshi_path.write_text(new_content)
            except Exception:
                pass

        except Exception:
            # Silently ignore to avoid crashing the Control Panel
            pass

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        # All changes are already applied in real-time to system via hyprctl
        # No separate config file needed - system state is the source of truth
        pass


class InputWidget(BaseControlWidget):
    """Input devices control widget"""

    def __init__(self, config):
        super().__init__(
            config, "Input Devices", "Keyboard/mouse/touchpad settings", "‚å®Ô∏è"
        )
        self.setup_controls()

    def setup_controls(self):
        """Setup input devices controls"""
        placeholder = Gtk.Label()
        placeholder.set_markup(
            '<span alpha="60%">Input device settings will be added here</span>'
        )
        placeholder.set_margin_top(10)
        placeholder.set_margin_bottom(10)
        self.controls_box.append(placeholder)


class PowerWidget(BaseControlWidget):
    """Power management control widget"""

    def __init__(self, config, window=None):
        super().__init__(
            config, "Power Management", "Battery and performance profiles", "üîã"
        )
        self.window = window
        self.setup_controls()

    def get_available_profiles(self):
        """Get available power profiles from powerprofilesctl"""
        # Standard profiles only
        standard_profiles = ["power-saver", "balanced", "performance"]

        try:
            import subprocess

            result = subprocess.run(
                ["powerprofilesctl", "get"], capture_output=True, text=True
            )
            if result.returncode == 0:
                current_profile = result.stdout.strip()
                # Ensure current profile is in standard list
                if current_profile not in standard_profiles:
                    current_profile = "balanced"
                return standard_profiles, current_profile
            return standard_profiles, "balanced"  # fallback
        except Exception:
            return standard_profiles, "balanced"  # fallback

    def setup_controls(self):
        """Setup power management controls"""
        power_config = self.config.get_power_config()

        # Get available profiles and current profile
        self.available_profiles, current_profile = self.get_available_profiles()

        # Use actual system profile, not config
        if current_profile in self.available_profiles:
            power_config["profile"] = current_profile

        # Profile label (add to title row)
        profile_names = ["Power Saver", "Balanced", "Performance"]
        current_index = 0
        for i, profile in enumerate(self.available_profiles):
            if profile == current_profile:
                current_index = i
                break
        self.profile_label = Gtk.Label()
        self.profile_label.set_markup(
            f'<span size="11000" alpha="75%">Profile: {profile_names[current_index]}</span>'
        )
        self.profile_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.profile_label)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(power_config["enabled"])
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Power profile slider with icons
        self.available_profiles = ["power-saver", "balanced", "performance"]
        power_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        self.profile_scale = Gtk.Scale.new_with_range(
            Gtk.Orientation.HORIZONTAL, 0, len(self.available_profiles) - 1, 1
        )

        # Set to current profile
        current_index = 0
        for i, profile in enumerate(self.available_profiles):
            if profile == current_profile:
                current_index = i
                break

        self.profile_scale.set_value(current_index)
        self.profile_scale.set_draw_value(False)
        self.profile_scale.set_sensitive(power_config["enabled"])
        self.profile_scale.set_margin_start(100)
        self.profile_scale.set_margin_end(100)
        self.profile_scale.connect("value-changed", self.on_profile_changed)

        # Add tick marks with correct icons
        self.profile_scale.add_mark(0, Gtk.PositionType.BOTTOM, "üê¢ Power Saver")
        self.profile_scale.add_mark(1, Gtk.PositionType.BOTTOM, "‚öñÔ∏è Balanced")
        self.profile_scale.add_mark(2, Gtk.PositionType.BOTTOM, "‚ö° Performance")

        power_box.append(self.profile_scale)
        self.controls_box.append(power_box)

    def on_toggle(self, switch, param):
        """Handle toggle switch"""
        state = switch.get_active()

        # Update slider sensitivity
        self.profile_scale.set_sensitive(state)

        # Mark changes pending
        self.mark_changes_pending()

    def on_profile_changed(self, scale):
        """Handle profile change with snapping"""
        value = scale.get_value()
        # Snap to nearest profile index
        snapped_value = round(value)

        if abs(value - snapped_value) > 0.1:
            scale.set_value(snapped_value)
            return

        # Apply profile change immediately
        index = int(snapped_value)
        if 0 <= index < len(self.available_profiles):
            profile_names = ["Power Saver", "Balanced", "Performance"]
            self.profile_label.set_markup(
                f'<span size="11000" alpha="75%">Profile: {profile_names[index]}</span>'
            )

            profile = self.available_profiles[index]
            try:
                import subprocess

                subprocess.run(["powerprofilesctl", "set", profile], check=False)
            except Exception:
                pass

        # Mark changes pending
        self.mark_changes_pending()

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        enabled = self.switch.get_active()
        selected_index = int(self.profile_scale.get_value())
        profile = (
            self.available_profiles[selected_index]
            if selected_index < len(self.available_profiles)
            else "balanced"
        )

        # Save to config
        self.config.set_power_config(enabled, profile)

        # Apply to system if enabled
        if enabled:
            try:
                import subprocess

                subprocess.run(["powerprofilesctl", "set", profile], check=True)
            except Exception:
                pass  # Silently fail if powerprofilesctl is not available


class BackgroundWidget(BaseControlWidget):
    """Wallpaper management widget"""

    def __init__(self, config, parent_window):
        super().__init__(
            config, "Wallpaper Management", "Customize wallpapers and themes", "üé®"
        )
        self.parent_window = parent_window
        self.backgrounds = []
        self.current_index = 0
        self.setup_controls()

    def setup_controls(self):
        """Setup background controls"""
        # Scan available backgrounds
        self.scan_backgrounds()

        # Dynamic Colors label (add to title row)
        dynamic_label = Gtk.Label(label="Dynamic Colors")
        dynamic_label.set_halign(Gtk.Align.END)
        self.title_row.append(dynamic_label)

        # Dynamic theming toggle (add to title row - RIGHTMOST)
        dynamic_theming_enabled = self.get_dynamic_theming_enabled()
        self.dynamic_toggle = Gtk.Switch()
        self.dynamic_toggle.set_active(dynamic_theming_enabled)
        self.dynamic_toggle.connect("notify::active", self.on_dynamic_theming_changed)
        self.title_row.append(self.dynamic_toggle)

        # Row with current wallpaper (left) and Add button (right)
        wallpaper_row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)

        # Current background label (left-aligned)
        self.current_bg_label = Gtk.Label()
        self.current_bg_label.set_markup(
            f'<span size="11000" alpha="75%">Current: {self.get_current_background_name()}</span>'
        )
        self.current_bg_label.set_halign(Gtk.Align.START)
        self.current_bg_label.set_hexpand(True)
        self.current_bg_label.set_wrap(True)
        self.current_bg_label.set_max_width_chars(40)
        self.current_bg_label.set_ellipsize(Pango.EllipsizeMode.END)
        wallpaper_row.append(self.current_bg_label)

        # Add custom background button (right-aligned)
        add_bg_button = Gtk.Button(label="Add My Wallpaper")
        add_bg_button.connect("clicked", self.on_add_background)
        add_bg_button.set_halign(Gtk.Align.END)
        wallpaper_row.append(add_bg_button)

        self.controls_box.append(wallpaper_row)

        # Background slider (using reusable function)
        if len(self.backgrounds) > 0:
            # Create marks with visual distinction for user backgrounds
            slider_marks = []
            system_count = len(
                [bg for bg in self.backgrounds if "riot_" in os.path.basename(bg)]
            )

            for i in range(len(self.backgrounds)):
                mark_text = str(i + 1)
                if i >= system_count:  # User background
                    mark_text = f"U{i - system_count + 1}"
                slider_marks.append((i + 1, mark_text))

            slider_container, _, self.bg_slider = self.create_slider(
                "",
                1,
                len(self.backgrounds),
                1,
                self.current_index + 1,
                True,
                slider_marks,
                self.on_background_changed,
                snap_increment=1,
            )
            scroller = Gtk.ScrolledWindow()
            scroller.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.NEVER)
            scroller.set_min_content_width(600)
            scroller.set_max_content_width(900)
            scroller.set_hexpand(True)
            scroller.set_child(slider_container)
            self.controls_box.append(scroller)

    def scan_backgrounds(self):
        """Scan for available background images"""
        import os
        import glob

        # System backgrounds
        system_bg_dir = os.path.expanduser("~/.local/share/archriot/backgrounds")
        user_bg_dir = os.path.expanduser("~/.config/archriot/backgrounds")

        system_backgrounds = []
        user_backgrounds = []

        # Scan system backgrounds
        if os.path.exists(system_bg_dir):
            patterns = ["*.jpg", "*.jpeg", "*.png", "*.webp"]
            for pattern in patterns:
                system_backgrounds.extend(
                    glob.glob(os.path.join(system_bg_dir, pattern))
                )

        # Scan user backgrounds
        if os.path.exists(user_bg_dir):
            patterns = ["*.jpg", "*.jpeg", "*.png", "*.webp"]
            for pattern in patterns:
                user_backgrounds.extend(glob.glob(os.path.join(user_bg_dir, pattern)))

        # Sort each group separately with natural sorting, then combine: system first, user at end
        import re

        def natural_sort_key(text):
            return [
                int(c) if c.isdigit() else c.lower() for c in re.split(r"(\d+)", text)
            ]

        system_backgrounds.sort(key=lambda x: natural_sort_key(os.path.basename(x)))
        user_backgrounds.sort(key=lambda x: natural_sort_key(os.path.basename(x)))
        self.backgrounds = system_backgrounds + user_backgrounds

        # Find current background index
        current_bg_file = os.path.expanduser("~/.config/archriot/.current-background")
        if os.path.exists(current_bg_file):
            try:
                with open(current_bg_file, "r") as f:
                    current_bg = f.read().strip()
                if current_bg in self.backgrounds:
                    self.current_index = self.backgrounds.index(current_bg)
            except:
                pass

        # Save background preferences for upgrade preservation
        self.save_background_preferences()

    def get_current_background_name(self):
        """Get the name of current background"""
        if self.backgrounds and self.current_index < len(self.backgrounds):
            import os

            return os.path.basename(self.backgrounds[self.current_index])
        return "None"

    def on_background_changed(self, scale):
        """Handle background slider change"""
        new_index = int(scale.get_value()) - 1
        if 0 <= new_index < len(self.backgrounds):
            self.current_index = new_index
            self.apply_background_change()

    def on_add_background(self, button):
        """Handle add custom background button"""
        import os

        dialog = Gtk.FileChooserDialog(
            title="Select Background Image", action=Gtk.FileChooserAction.OPEN
        )
        dialog.set_transient_for(self.parent_window.window)
        dialog.set_modal(True)
        dialog.set_size_request(800, 700)

        dialog.add_buttons(
            "_Cancel", Gtk.ResponseType.CANCEL, "_Open", Gtk.ResponseType.OK
        )

        # Set default directory to Pictures
        pictures_dir = os.path.expanduser("~/Pictures")
        if os.path.exists(pictures_dir):
            pictures_file = Gio.File.new_for_path(pictures_dir)
            dialog.set_current_folder(pictures_file)

        # Add image file filters
        filter_images = Gtk.FileFilter()
        filter_images.set_name("Image files")
        filter_images.add_mime_type("image/jpeg")
        filter_images.add_mime_type("image/png")
        filter_images.add_mime_type("image/webp")
        filter_images.add_pattern("*.jpg")
        filter_images.add_pattern("*.jpeg")
        filter_images.add_pattern("*.png")
        filter_images.add_pattern("*.webp")
        dialog.set_filter(filter_images)

        dialog.connect("response", self.on_file_dialog_response)
        dialog.present()

    def on_file_dialog_response(self, dialog, response):
        """Handle file dialog response"""
        if response == Gtk.ResponseType.OK:
            file = dialog.get_file()
            if file:
                self.add_custom_background(file.get_path())
        dialog.destroy()

    def add_custom_background(self, file_path):
        """Add a custom background image"""
        import os
        import shutil

        # Create user backgrounds directory
        user_bg_dir = os.path.expanduser("~/.config/archriot/backgrounds")
        os.makedirs(user_bg_dir, exist_ok=True)

        # Get file extension
        _, ext = os.path.splitext(file_path)

        # Find next available user background number
        existing_files = [f for f in os.listdir(user_bg_dir) if f.startswith("user_")]
        next_num = len(existing_files) + 1

        # Copy file to user backgrounds directory
        dest_filename = f"user_{next_num:02d}{ext}"
        dest_path = os.path.join(user_bg_dir, dest_filename)

        try:
            shutil.copy2(file_path, dest_path)
            print(f"Added background: {dest_filename}")

            # Refresh background list and update UI
            self.refresh_backgrounds()

        except Exception as e:
            print(f"Error adding background: {e}")

    def refresh_backgrounds(self):
        """Refresh the background list and update slider"""
        old_count = len(self.backgrounds)
        self.scan_backgrounds()
        new_count = len(self.backgrounds)

        if new_count != old_count:
            # Remove old slider
            if hasattr(self, "bg_slider") and self.bg_slider.get_parent():
                self.controls_box.remove(self.bg_slider.get_parent())

            # Create new slider with updated range (using reusable function)
            if len(self.backgrounds) > 0:
                # Create marks with visual distinction for user backgrounds
                bg_marks = []
                system_count = len(
                    [bg for bg in self.backgrounds if "riot_" in os.path.basename(bg)]
                )

                for i in range(len(self.backgrounds)):
                    mark_text = str(i + 1)
                    if i >= system_count:  # User background
                        mark_text = f"U{i - system_count + 1}"
                    bg_marks.append((i + 1, mark_text))

                slider_container, _, self.bg_slider = self.create_slider(
                    "",
                    1,
                    len(self.backgrounds),
                    1,
                    self.current_index + 1,
                    True,
                    bg_marks,
                    self.on_background_changed,
                    snap_increment=1,
                )
                scroller = Gtk.ScrolledWindow()
                scroller.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.NEVER)
                scroller.set_min_content_width(600)
                scroller.set_max_content_width(900)
                scroller.set_hexpand(True)
                scroller.set_child(slider_container)
                self.controls_box.append(scroller)

    def apply_background_change(self):
        """Apply the selected background"""
        if self.backgrounds and 0 <= self.current_index < len(self.backgrounds):
            import os
            import subprocess

            new_bg = self.backgrounds[self.current_index]

            # Update current background file
            current_bg_file = os.path.expanduser(
                "~/.config/archriot/.current-background"
            )
            try:
                os.makedirs(os.path.dirname(current_bg_file), exist_ok=True)
                with open(current_bg_file, "w") as f:
                    f.write(new_bg)
            except:
                pass

            # Apply background via swaybg (with proper process detachment like swaybg-next)
            try:
                subprocess.run(["pkill", "-x", "swaybg"], check=False)
                import time

                time.sleep(0.5)
                subprocess.Popen(
                    ["nohup", "setsid", "swaybg", "-i", new_bg, "-m", "fill"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    preexec_fn=os.setsid,
                )
            except:
                pass

            # Update theme colors if dynamic theming is enabled
            archriot_bin = os.path.expanduser(
                "~/.local/share/archriot/install/archriot"
            )
            if os.path.isfile(archriot_bin):
                try:
                    print(f"DEBUG: Calling theming system with path: {new_bg}")
                    result = subprocess.run(
                        [archriot_bin, "--apply-wallpaper-theme", new_bg],
                        check=False,
                        capture_output=True,
                        text=True,
                    )
                    print(f"DEBUG: Theming command result: {result.returncode}")
                    if result.stdout:
                        print(f"DEBUG: stdout: {result.stdout}")
                    if result.stderr:
                        print(f"DEBUG: stderr: {result.stderr}")
                except Exception as e:
                    print(f"DEBUG: Exception calling theming system: {e}")

            # Update UI
            self.current_bg_label.set_markup(
                f'<span size="11000" alpha="75%">Current: {os.path.basename(new_bg)}</span>'
            )

            # Save preferences after background change
            self.save_background_preferences()

    def save_background_preferences(self):
        """Save background preferences for upgrade preservation"""
        import json
        import os

        prefs_file = os.path.expanduser("~/.config/archriot/background-prefs.json")
        os.makedirs(os.path.dirname(prefs_file), exist_ok=True)

        current_bg = ""
        if self.backgrounds and 0 <= self.current_index < len(self.backgrounds):
            current_bg = os.path.basename(self.backgrounds[self.current_index])

        # Get list of user background filenames
        user_bg_dir = os.path.expanduser("~/.config/archriot/backgrounds")
        user_backgrounds = []
        if os.path.exists(user_bg_dir):
            user_backgrounds = [
                f
                for f in os.listdir(user_bg_dir)
                if f.lower().endswith((".jpg", ".jpeg", ".png", ".webp"))
            ]

        preferences = {
            "current_background": current_bg,
            "user_backgrounds": user_backgrounds,
        }

        # Don't overwrite dynamic_theming setting - let ArchRiot binary manage it
        # Read existing config to preserve dynamic_theming setting
        if os.path.exists(prefs_file):
            try:
                with open(prefs_file, "r") as f:
                    existing_prefs = json.load(f)
                    if "dynamic_theming" in existing_prefs:
                        preferences["dynamic_theming"] = existing_prefs[
                            "dynamic_theming"
                        ]
                    if "generated_palette" in existing_prefs:
                        preferences["generated_palette"] = existing_prefs[
                            "generated_palette"
                        ]
            except:
                pass

        try:
            with open(prefs_file, "w") as f:
                json.dump(preferences, f, indent=2)
        except Exception as e:
            print(f"Warning: Could not save background preferences: {e}")

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        self.parent_window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply any pending changes"""
        # Background changes are applied immediately
        pass

    def get_dynamic_theming_enabled(self):
        """Get the current dynamic theming setting"""
        import json
        import os

        prefs_file = os.path.expanduser("~/.config/archriot/background-prefs.json")
        if os.path.exists(prefs_file):
            try:
                with open(prefs_file, "r") as f:
                    prefs = json.load(f)
                    return prefs.get("dynamic_theming", False)
            except:
                pass
        return False

    def on_dynamic_theming_changed(self, switch, param):
        """Handle dynamic theming toggle change"""
        import subprocess
        import os

        state = switch.get_active()
        self.dynamic_theming_enabled = state

        # Call ArchRiot binary to toggle dynamic theming
        archriot_bin = os.path.expanduser("~/.local/share/archriot/install/archriot")
        if os.path.isfile(archriot_bin):
            try:
                subprocess.run(
                    [archriot_bin, "--toggle-dynamic-theming", str(state).lower()],
                    check=False,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                )

                # Apply current wallpaper to trigger color update (static or dynamic)
                # Read current background from saved config, not UI state
                current_bg_path = self.get_current_background_from_config()
                if current_bg_path:
                    subprocess.run(
                        [archriot_bin, "--apply-wallpaper-theme", current_bg_path],
                        check=False,
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL,
                    )
            except:
                pass

        # Save preferences
        self.save_background_preferences()

    def get_current_background_from_config(self):
        """Get the current background path from saved config"""
        import json
        import os

        prefs_file = os.path.expanduser("~/.config/archriot/background-prefs.json")
        backgrounds_dir = os.path.expanduser("~/.local/share/archriot/backgrounds")

        if os.path.exists(prefs_file):
            try:
                with open(prefs_file, "r") as f:
                    prefs = json.load(f)
                    current_bg = prefs.get("current_background", "riot_01.jpg")
                    return os.path.join(backgrounds_dir, current_bg)
            except:
                pass

        # Fallback to default
        return os.path.join(backgrounds_dir, "riot_01.jpg")


class SecurityWidget(BaseControlWidget):
    """Security control widget"""

    def __init__(self, config):
        super().__init__(config, "Security", "Firewall and security settings", "üõ°Ô∏è")
        self.setup_controls()

    def setup_controls(self):
        """Setup security controls"""
        placeholder = Gtk.Label()
        placeholder.set_markup(
            '<span alpha="60%">Security settings will be added here</span>'
        )
        placeholder.set_margin_top(10)
        placeholder.set_margin_bottom(10)
        self.controls_box.append(placeholder)


class ControlPanelWindow:
    """Main control panel window that assembles all widgets"""

    def __init__(self):
        # Initialize configuration
        self.config = ArchRiotConfig()

        # Initialize state tracking
        self.has_unsaved_changes = False

        # Create main window
        self.window = Gtk.Window()
        self.window.set_title("ArchRiot Control Panel")
        self.window.set_default_size(1000, 800)
        self.window.set_resizable(True)
        self.window.set_modal(True)
        self.window.add_css_class("archriot-control-panel")

        # Create main layout
        self.create_layout()

        # Connect window events
        self.window.connect("close-request", self.on_window_close)

    def create_layout(self):
        # Create the main window layout
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        main_box.set_margin_start(15)
        main_box.set_margin_end(15)
        main_box.set_margin_top(10)
        main_box.set_margin_bottom(15)

        # Header
        self.add_header(main_box)

        # Content area with widgets
        self.add_content_area(main_box)

        # Footer
        self.add_footer(main_box)

        self.window.set_child(main_box)

    def add_header(self, container):
        """Add header with title and version info"""
        header_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)

        # Main title with version
        version = self.get_archriot_version()
        title_label = Gtk.Label()
        title_label.set_markup(
            f'<span size="20000" weight="bold" foreground="#bb9af7">ArchRiot <span alpha="60%">v{version}</span> Control Panel</span>'
        )
        title_label.set_halign(Gtk.Align.CENTER)
        header_box.append(title_label)

        container.append(header_box)

    def add_content_area(self, container):
        """Add main content area with control widgets"""
        # Create scrollable content
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        scrolled_window.set_vexpand(True)

        content_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        content_box.set_margin_start(20)
        content_box.set_margin_end(20)
        content_box.set_margin_top(10)
        content_box.set_margin_bottom(20)

        # Create and add widgets
        self.pomodoro_widget = PomodoroWidget(self.config, self)
        content_box.append(self.pomodoro_widget.widget)

        self.bluelight_widget = BlueLightWidget(self.config, self)
        content_box.append(self.bluelight_widget.widget)

        self.mullvad_widget = MullvadWidget(self.config, self)
        content_box.append(self.mullvad_widget.widget)

        # Audio widget removed - functionality not needed
        # self.audio_widget = AudioWidget(self.config, self)
        # content_box.append(self.audio_widget.widget)

        self.camera_widget = CameraWidget(self.config, self)
        content_box.append(self.camera_widget.widget)

        self.display_widget = DisplayWidget(self.config, self)
        content_box.append(self.display_widget.widget)

        # TODO: Re-enable these widgets later
        # self.input_widget = InputWidget(self.config)
        # content_box.append(self.input_widget.widget)

        self.power_widget = PowerWidget(self.config, self)
        content_box.append(self.power_widget.widget)

        self.background_widget = BackgroundWidget(self.config, self)
        content_box.append(self.background_widget.widget)

        # TODO: Re-enable these widgets later
        # self.security_widget = SecurityWidget(self.config)
        # content_box.append(self.security_widget.widget)

        scrolled_window.set_child(content_box)
        container.append(scrolled_window)

    def add_footer(self, container):
        """Add footer with action buttons"""
        # Footer removed - SUPER+Q handles window closing
        pass

    def apply_all_changes(self):
        """Apply all pending changes from all widgets"""
        if hasattr(self, "pomodoro_widget") and hasattr(
            self.pomodoro_widget, "apply_changes"
        ):
            self.pomodoro_widget.apply_changes()
        if hasattr(self, "bluelight_widget") and hasattr(
            self.bluelight_widget, "apply_changes"
        ):
            self.bluelight_widget.apply_changes()
        if hasattr(self, "mullvad_widget") and hasattr(
            self.mullvad_widget, "apply_changes"
        ):
            self.mullvad_widget.apply_changes()
        # Audio widget removed
        # if hasattr(self, 'audio_widget') and hasattr(self.audio_widget, 'apply_changes'):
        #     self.audio_widget.apply_changes()
        if hasattr(self, "camera_widget") and hasattr(
            self.camera_widget, "apply_changes"
        ):
            self.camera_widget.apply_changes()
        if hasattr(self, "display_widget") and hasattr(
            self.display_widget, "apply_changes"
        ):
            self.display_widget.apply_changes()
        # TODO: Re-enable these widgets later
        # if hasattr(self, 'input_widget') and hasattr(self.input_widget, 'apply_changes'):
        #     self.input_widget.apply_changes()
        if hasattr(self, "power_widget") and hasattr(
            self.power_widget, "apply_changes"
        ):
            self.power_widget.apply_changes()
        # TODO: Re-enable these widgets later
        # if hasattr(self, 'security_widget') and hasattr(self.security_widget, 'apply_changes'):
        #     self.security_widget.apply_changes()

        self.has_unsaved_changes = False
        print("All changes applied!")

    def on_window_close(self, window):
        """Handle window close request"""
        if hasattr(self, "app"):
            self.app.quit()
        return False

    def get_archriot_version(self):
        """Read ArchRiot version from VERSION file"""
        home_dir = Path.home()
        version_path = home_dir / ".local" / "share" / "archriot" / "VERSION"

        try:
            with open(version_path, "r") as f:
                version = f.read().strip()
                return version
        except Exception:
            return "unknown"


class ControlPanelApplication(Gtk.Application):
    """GTK Application wrapper"""

    def __init__(self):
        super().__init__(application_id="net.archriot.control-panel")

    def do_activate(self):
        """Activate the application"""
        if not self.get_windows():
            window = ControlPanelWindow()
            window.app = self
            self.add_window(window.window)

        # Apply CSS styling
        self.apply_css()

        # Show the window
        self.get_windows()[0].present()

    def apply_css(self):
        """Apply ArchRiot theming"""
        css_provider = Gtk.CssProvider()
        css_data = """
        * {
            font-family: "Paper Mono", "Symbols Nerd Font", "Symbols Nerd Font Mono", monospace;
        }

        window {
            background: rgba(0, 0, 0, 1.0);
            color: #cdd6f4;
            font-family: "Paper Mono", "Symbols Nerd Font", "Symbols Nerd Font Mono", monospace;
        }

        label {
            color: #cdd6f4;
            font-family: "Paper Mono", "Symbols Nerd Font", "Symbols Nerd Font Mono", monospace;
        }

        frame {
            border: 1px solid rgba(157, 123, 216, 0.3);
            border-radius: 8px;
        }



        button {
            background: rgba(75, 0, 130, 1.0);
            color: #ffffff;
            border: none;
            border-radius: 6px;
            padding: 4px 12px;
            font-weight: bold;
            min-height: 24px;
            font-family: "Paper Mono", "Symbols Nerd Font", "Symbols Nerd Font Mono", monospace;
        }

        button:hover {
            background: rgba(102, 51, 153, 1.0);
        }



        entry {
            background: rgba(20, 21, 31, 0.9);
            color: #cdd6f4;
            border: 1px solid rgba(157, 123, 216, 0.3);
            border-radius: 6px;
            min-height: 24px;
            padding: 4px 8px;
        }

        entry:focus {
            border: 1px solid rgba(187, 154, 247, 0.6);
        }

        scrolledwindow {
            border: none;
            background: rgba(0, 0, 0, 0.7);
        }
        """

        css_provider.load_from_data(css_data.encode())

        # Apply CSS to default display
        display = Gdk.Display.get_default()
        Gtk.StyleContext.add_provider_for_display(
            display, css_provider, Gtk.STYLE_PROVIDER_PRIORITY_USER
        )


def main():
    """Main entry point"""
    import argparse

    parser = argparse.ArgumentParser(description="ArchRiot Control Panel")
    parser.add_argument(
        "--reapply",
        action="store_true",
        help="Re-apply saved settings to fresh config files",
    )

    args = parser.parse_args()

    if args.reapply:
        reapply_saved_settings()
        return 0

    app = ControlPanelApplication()
    return app.run(sys.argv)


def reapply_saved_settings():
    """Re-apply all saved user settings to fresh config files"""
    try:
        # Import config module to read saved settings
        config_class = import_config_module()
        if not config_class:
            return

        # Create config instance
        config = config_class()

        # Re-apply blue light filter setting
        bluelight_config = config.get_bluelight_config()

        if bluelight_config["enabled"] and bluelight_config["temperature"] != 3500:
            apply_bluelight_setting(bluelight_config["temperature"])
            print(f"Re-applied blue light filter: {bluelight_config['temperature']}K")
        elif not bluelight_config["enabled"]:
            disable_bluelight_setting()
            print("Re-applied blue light filter: disabled")

        # TODO: Add other settings re-application here as needed

    except Exception as e:
        print(f"Error re-applying settings: {e}")


def apply_bluelight_setting(temperature):
    """Apply blue light temperature setting to hyprland.conf"""
    import re
    from pathlib import Path

    hyprland_config = Path.home() / ".config" / "hypr" / "hyprland.conf"
    if hyprland_config.exists():
        content = hyprland_config.read_text()
        content = re.sub(
            r"exec-once = hyprsunset -t \d+",
            f"exec-once = hyprsunset -t {temperature}",
            content,
        )
        hyprland_config.write_text(content)


def disable_bluelight_setting():
    """Disable blue light filter in hyprland.conf"""
    import re
    from pathlib import Path

    hyprland_config = Path.home() / ".config" / "hypr" / "hyprland.conf"
    if hyprland_config.exists():
        content = hyprland_config.read_text()
        content = re.sub(
            r"exec-once = hyprsunset -t \d+",
            "# exec-once = hyprsunset -t 3500  # Disabled via Control Panel",
            content,
        )
        hyprland_config.write_text(content)


if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)
