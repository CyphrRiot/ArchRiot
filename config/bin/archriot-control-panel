#!/usr/bin/env python3
"""
ArchRiot Control Panel
Centralized settings interface for ArchRiot components
"""

import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Gdk', '4.0')
gi.require_version('GdkPixbuf', '2.0')
from gi.repository import Gtk, Gdk, GLib, Pango, GdkPixbuf, Gio
import os
import sys
import time
from pathlib import Path

class ArchRiotDialog:
    """Reusable ArchRiot-themed dialog with proper background"""

    def __init__(self, title, content, parent_window=None):
        self.dialog = Gtk.Window()
        self.dialog.set_title(title)
        self.dialog.set_default_size(700, 600)
        self.dialog.set_resizable(True)
        self.dialog.set_modal(True)
        self.dialog.add_css_class("archriot-control-panel")

        if parent_window:
            self.dialog.set_transient_for(parent_window)

        self.create_layout(title, content)

    def create_layout(self, title, content):
        """Create the dialog layout using proven main window approach"""
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=20)
        main_box.set_margin_start(30)
        main_box.set_margin_end(30)
        main_box.set_margin_top(15)
        main_box.set_margin_bottom(20)

        # Title
        title_label = Gtk.Label()
        title_label.set_markup(f'<span size="28000" weight="bold" foreground="#bb9af7" font_family="Hack Nerd Font Mono">{title}</span>')
        title_label.set_halign(Gtk.Align.CENTER)
        main_box.append(title_label)

        # Content frame - same as main window
        content_frame = Gtk.Frame()
        content_frame.set_margin_top(10)
        content_frame.add_css_class("archriot-control-panel")

        content_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=15)
        content_box.set_margin_start(20)
        content_box.set_margin_end(20)
        content_box.set_margin_top(20)
        content_box.set_margin_bottom(20)

        # Content text
        content_label = Gtk.Label()
        content_label.set_markup(f'<span size="12000" font_family="Hack Nerd Font Mono">{content}</span>')
        content_label.set_wrap(True)
        content_label.set_halign(Gtk.Align.START)
        content_box.append(content_label)

        content_frame.set_child(content_box)
        main_box.append(content_frame)

        # Close button
        close_button = Gtk.Button(label="Close")
        close_button.set_halign(Gtk.Align.CENTER)
        close_button.connect("clicked", lambda x: self.dialog.close())
        # Apply Hack Nerd Font to button
        close_button.get_child().set_markup('<span font_family="Hack Nerd Font Mono">Close</span>')
        main_box.append(close_button)

        self.dialog.set_child(main_box)

    def show(self):
        """Show the dialog"""
        self.dialog.present()

# Import our configuration manager
def import_config_module():
    """Import the ArchRiot configuration system"""
    # Get script directory, handle both __file__ and execution contexts
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
    except NameError:
        # Fallback when __file__ is not defined (like in exec context)
        script_dir = os.getcwd()

    # Try from same directory first (development)
    config_script = os.path.join(script_dir, 'archriot-config')

    if os.path.exists(config_script):
        # Execute the config script to get the ArchRiotConfig class
        global_vars = {}
        with open(config_script, 'r') as f:
            exec(f.read(), global_vars)
        return global_vars['ArchRiotConfig']
    else:
        # Try from installed location
        home_bin = str(Path.home() / '.local' / 'share' / 'archriot' / 'config' / 'bin' / 'archriot-config')
        if os.path.exists(home_bin):
            global_vars = {}
            with open(home_bin, 'r') as f:
                exec(f.read(), global_vars)
            return global_vars['ArchRiotConfig']
        else:
            # Create a minimal fallback config class
            class FallbackConfig:
                def __init__(self):
                    pass
                def get_pomodoro_config(self):
                    return {'enabled': True, 'duration': 25}
                def get_bluelight_config(self):
                    import re
                    from pathlib import Path

                    # Read current settings from hyprland.conf
                    hyprland_config = Path.home() / '.config' / 'hypr' / 'hyprland.conf'
                    enabled = True
                    temperature = 3500  # fallback

                    if hyprland_config.exists():
                        content = hyprland_config.read_text()
                        # Check if hyprsunset line is commented out (disabled)
                        if re.search(r'^\s*#.*hyprsunset', content, re.MULTILINE):
                            enabled = False
                        # Extract temperature from active hyprsunset line
                        match = re.search(r'exec-once = hyprsunset -t (\d+)', content)
                        if match:
                            temperature = int(match.group(1))
                            enabled = True

                    return {'enabled': enabled, 'temperature': temperature}
                def get_mullvad_config(self):
                    return {'enabled': False, 'account_number': '', 'auto_connect': False}
                def get_display_config(self):
                    return {'enabled': True, 'resolution': 1920, 'scaling': 100}
                def get_power_config(self):
                    return {'enabled': True, 'profile': 'balanced'}
                def set_pomodoro_config(self, enabled, duration):
                    pass
                def set_bluelight_config(self, enabled, temperature):
                    # This is handled by the BlueLightWidget directly updating hyprland.conf
                    # No separate config file needed since hyprland.conf is the source of truth
                    pass
                def set_mullvad_config(self, enabled, account_number='', auto_connect=False):
                    pass
                def set_display_config(self, enabled, resolution, scaling):
                    pass
                def set_power_config(self, enabled, profile):
                    pass
                def backup_config(self, name=None):
                    return "/tmp/fallback-backup"
            return FallbackConfig

ArchRiotConfig = import_config_module()

class BaseControlWidget:
    """Base class for control widgets with toggle and value control"""

    def __init__(self, config, title, description, icon):
        self.config = config
        self.title = title
        self.description = description
        self.icon = icon
        self.timeout_id = None

        # Create main container
        self.widget = self.create_section_frame()

    def create_section_frame(self):
        """Create the main frame for this widget"""
        frame = Gtk.Frame()
        frame.set_margin_bottom(3)

        # Create main container
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        main_box.set_margin_start(10)
        main_box.set_margin_end(10)
        main_box.set_margin_top(8)
        main_box.set_margin_bottom(8)

        # Title row with toggle
        self.title_row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)

        # Title
        title_label = Gtk.Label()
        title_label.set_markup(f'<span size="14000" weight="bold" foreground="#bb9af7">{self.icon} {self.title}</span>')
        title_label.set_halign(Gtk.Align.START)
        title_label.set_hexpand(True)
        self.title_row.append(title_label)

        main_box.append(self.title_row)

        # Controls container
        self.controls_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        main_box.append(self.controls_box)

        frame.set_child(main_box)
        return frame

    def create_toggle(self, label_text, initial_state, callback):
        """Create a toggle switch"""
        row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        label = Gtk.Label(label=label_text)
        label.set_halign(Gtk.Align.START)
        label.set_hexpand(True)

        switch = Gtk.Switch()
        switch.set_active(initial_state)
        switch.connect("notify::active", callback)

        row.append(label)
        row.append(switch)
        return row, switch

    def create_slider(self, label_text, min_val, max_val, step, current_val, enabled, marks, callback, snap_increment=None):
        """Create a slider with optional label and snapping - single reusable function for all sliders"""
        container = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        label = None
        if label_text:  # Only create label if text is provided
            label = Gtk.Label(label=label_text)
            label.set_halign(Gtk.Align.START)
            container.append(label)

        scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, min_val, max_val, step)
        scale.set_value(current_val)
        scale.set_draw_value(False)
        scale.set_sensitive(enabled)

        # Create snapping wrapper if snap_increment provided
        if snap_increment:
            def snapping_callback(scale):
                value = scale.get_value()
                snapped_value = round(value / snap_increment) * snap_increment
                if abs(value - snapped_value) > (snap_increment * 0.01):
                    scale.set_value(snapped_value)
                    return
                callback(scale)
            scale.connect("value-changed", snapping_callback)
        else:
            scale.connect("value-changed", callback)

        # Add tick marks
        for mark_val, mark_label in marks:
            scale.add_mark(mark_val, Gtk.PositionType.BOTTOM, mark_label)

        container.append(scale)
        return container, label, scale

    def debounced_save(self, save_function, delay_ms=500):
        """Debounce save operations"""
        if self.timeout_id:
            GLib.source_remove(self.timeout_id)
        self.timeout_id = GLib.timeout_add(delay_ms, save_function)

class PomodoroWidget(BaseControlWidget):
    """Pomodoro timer control widget"""

    def __init__(self, config, window=None):
        super().__init__(config, "Pomodoro Timer", "Control the built-in Waybar Pomodoro timer", "🍅")
        self.window = window
        self.setup_controls()

    def setup_controls(self):
        """Setup Pomodoro-specific controls"""
        pomodoro_config = self.config.get_pomodoro_config()

        # Duration label (add to title row)
        self.duration_label = Gtk.Label()
        self.duration_label.set_markup(f'<span size="11000" alpha="75%">Duration: {pomodoro_config["duration"]} minutes</span>')
        self.duration_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.duration_label)

        # Learn More link (add to title row)
        learn_link = Gtk.Button(label="Learn More")
        learn_link.connect("clicked", self.on_learn_more_clicked)
        learn_link.set_halign(Gtk.Align.END)
        self.title_row.append(learn_link)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(pomodoro_config['enabled'])
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Duration slider (just the slider, no label)
        duration_marks = [(i, f"{i}m") for i in range(5, 65, 5)]
        slider_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        self.duration_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 5, 60, 1)
        self.duration_scale.set_value(pomodoro_config['duration'])
        self.duration_scale.set_draw_value(False)
        self.duration_scale.set_sensitive(pomodoro_config['enabled'])
        self.duration_scale.connect("value-changed", self.on_duration_changed)

        # Add tick marks
        for mark_val, mark_label in duration_marks:
            self.duration_scale.add_mark(mark_val, Gtk.PositionType.BOTTOM, mark_label)

        slider_box.append(self.duration_scale)
        self.controls_box.append(slider_box)

    def on_toggle(self, switch, param):
        """Handle toggle switch"""
        state = switch.get_active()
        duration = int(self.duration_scale.get_value())

        # Update slider sensitivity
        self.duration_scale.set_sensitive(state)

        # Apply toggle change immediately to waybar
        self.apply_toggle_change(state, duration)

        # Mark changes pending
        self.mark_changes_pending()

    def on_duration_changed(self, scale):
        """Handle duration change with snapping"""
        value = scale.get_value()
        # Snap to nearest 5-minute increment (5, 10, 15, 20, 25, etc.)
        snapped_value = round(value / 5) * 5

        if abs(value - snapped_value) > 0.5:
            scale.set_value(snapped_value)
            return

        duration = int(snapped_value)
        self.duration_label.set_markup(f'<span size="11000" alpha="75%">Duration: {duration} minutes</span>')

        # Apply duration change immediately to waybar
        self.apply_duration_change(duration)

        # Mark changes pending
        self.mark_changes_pending()

    def apply_toggle_change(self, enabled, duration):
        """Apply toggle change immediately to waybar"""
        try:
            import subprocess
            # Save config immediately so waybar script can read it
            self.config.set_pomodoro_config(enabled, duration)
            # Refresh waybar pomodoro module
            subprocess.run(['pkill', '-RTMIN+8', 'waybar'], check=False)
        except Exception as e:
            print(f"Pomodoro waybar update error: {e}")

    def apply_duration_change(self, duration):
        """Apply duration change immediately to waybar"""
        try:
            import subprocess
            enabled = self.switch.get_active()
            # Save config immediately so waybar script can read it
            self.config.set_pomodoro_config(enabled, duration)
            # Refresh waybar pomodoro module
            subprocess.run(['pkill', '-RTMIN+8', 'waybar'], check=False)
        except Exception as e:
            print(f"Pomodoro waybar update error: {e}")

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        enabled = self.switch.get_active()
        duration = int(self.duration_scale.get_value())

        # Save to config (system changes already applied in real-time)
        self.config.set_pomodoro_config(enabled, duration)

    def on_learn_more_clicked(self, button):
        """Handle Learn More button click"""
        self.show_pomodoro_dialog()

    def show_pomodoro_dialog(self):
        """Show enhanced Pomodoro dialog with image"""
        dialog = Gtk.Window()
        dialog.set_title("🍅 Pomodoro Technique")
        dialog.set_default_size(800, 700)
        dialog.set_resizable(True)
        dialog.set_modal(True)
        dialog.add_css_class("archriot-control-panel")

        if self.window:
            dialog.set_transient_for(self.window.window)

        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=20)
        main_box.set_margin_start(10)  # Reduced margins
        main_box.set_margin_end(10)
        main_box.set_margin_top(10)
        main_box.set_margin_bottom(10)

        # Title
        title_label = Gtk.Label()
        title_label.set_markup('<span size="28000" weight="bold" foreground="#bb9af7" font_family="Hack Nerd Font Mono">🍅 Pomodoro Technique</span>')
        title_label.set_halign(Gtk.Align.CENTER)
        main_box.append(title_label)

        # Content frame
        content_frame = Gtk.Frame()
        content_frame.set_margin_top(10)

        content_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=15)
        content_box.set_margin_start(10)  # Reduced margins
        content_box.set_margin_end(10)
        content_box.set_margin_top(10)
        content_box.set_margin_bottom(10)

        # Add pomodoro image
        try:
            import os
            import sys
            script_file = sys.argv[0] if sys.argv and sys.argv[0] else os.path.expanduser("~/.local/share/archriot/config/bin/archriot-control-panel")
            script_dir = os.path.dirname(os.path.abspath(script_file))
            archriot_dir = os.path.dirname(script_dir)
            image_path = os.path.join(archriot_dir, "config", "images", "pomodoro.png")

            if os.path.exists(image_path):
                # Load the original pixbuf
                pixbuf = GdkPixbuf.Pixbuf.new_from_file(image_path)

                # Create an image widget
                image = Gtk.Image()
                image.set_halign(Gtk.Align.FILL)
                image.set_hexpand(True)  # Allow image to expand horizontally
                image.set_margin_bottom(10)

                # Function to scale pixbuf based on dialog width
                def scale_pixbuf(widget, pixbuf):
                    # Get the dialog's current width, accounting for margins
                    dialog_width = widget.get_allocated_width() - main_box.get_margin_start() - main_box.get_margin_end() - content_box.get_margin_start() - content_box.get_margin_end() - content_frame.get_margin_start() - content_frame.get_margin_end()
                    if dialog_width <= 0:
                        dialog_width = 800  # Fallback to default width

                    # Get original dimensions
                    orig_width = pixbuf.get_width()
                    orig_height = pixbuf.get_height()

                    # Calculate scaled height to maintain aspect ratio
                    scale_factor = dialog_width / orig_width
                    new_height = int(orig_height * scale_factor)

                    # Scale the pixbuf
                    scaled_pixbuf = pixbuf.scale_simple(dialog_width, new_height, GdkPixbuf.InterpType.BILINEAR)
                    image.set_from_pixbuf(scaled_pixbuf)

                # Initial scaling
                scale_pixbuf(dialog, pixbuf)

                # Connect to size-allocate to update image on resize
                def on_size_allocate(widget, allocation):
                    scale_pixbuf(widget, pixbuf)

                dialog.connect("size-allocate", on_size_allocate)
                content_box.append(image)
        except Exception as e:
            print(f"Could not load pomodoro image: {e}")

        # Content text
        content = """The Pomodoro Technique is a time management method developed by Francesco Cirillo in the late 1980s. It uses a timer to break work into intervals, traditionally 25 minutes in length, separated by short breaks.

    <b>How it works:</b>

    1. Choose a task to work on
    2. Set the timer for 25 minutes (or your preferred duration)
    3. Work on the task until the timer rings
    4. Take a short 5-minute break
    5. After 4 pomodoros, take a longer 15-30 minute break

    <b>Benefits:</b>

    • Improves focus and concentration
    • Reduces mental fatigue
    • Increases productivity
    • Helps overcome procrastination
    • Makes time tracking easier
    • Reduces burnout

    The technique is named after the tomato-shaped kitchen timer that Cirillo used as a university student.

    ArchRiot's built-in Pomodoro timer integrates directly with your Waybar, making it easy to stay focused while working in your Hyprland environment."""

        content_label = Gtk.Label()
        content_label.set_markup(f'<span size="12000" font_family="Hack Nerd Font Mono">{content}</span>')
        content_label.set_wrap(True)
        content_label.set_halign(Gtk.Align.START)
        content_box.append(content_label)

        content_frame.set_child(content_box)
        main_box.append(content_frame)

        # Close button
        close_button = Gtk.Button(label="Close")
        close_button.set_halign(Gtk.Align.CENTER)
        close_button.connect("clicked", lambda x: dialog.close())
        close_button.get_child().set_markup('<span font_family="Hack Nerd Font Mono">Close</span>')
        main_box.append(close_button)

        dialog.set_child(main_box)
        dialog.present()

class BlueLightWidget(BaseControlWidget):
    """Blue light filter control widget"""

    def __init__(self, config, window=None):
        super().__init__(config, "Blue Light Filter", "Control the built-in hyprsunset blue light filter", "💡")
        self.window = window
        self.setup_controls()

    def _read_bluelight_from_hyprland(self):
        """Read current blue light settings directly from hyprland.conf"""
        import re
        from pathlib import Path

        hyprland_config = Path.home() / '.config' / 'hypr' / 'hyprland.conf'
        enabled = True
        temperature = 3500  # fallback

        if hyprland_config.exists():
            content = hyprland_config.read_text()
            # Check if hyprsunset line is commented out (disabled)
            if re.search(r'^\s*#.*hyprsunset', content, re.MULTILINE):
                enabled = False
            # Extract temperature from active hyprsunset line
            match = re.search(r'exec-once = hyprsunset -t (\d+)', content)
            if match:
                temperature = int(match.group(1))
                enabled = True

        return {'enabled': enabled, 'temperature': temperature}

    def setup_controls(self):
        """Setup blue light filter controls"""
        bluelight_config = self._read_bluelight_from_hyprland()

        # Temperature label (add to title row)
        self.temp_label = Gtk.Label()
        self.temp_label.set_markup(f'<span size="11000" alpha="75%">Temperature: {bluelight_config["temperature"]}K</span>')
        self.temp_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.temp_label)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(bluelight_config['enabled'])
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Temperature slider (using reusable function)
        temp_marks = [(i, f"{i}K") for i in range(2500, 5500, 500)]
        slider_container, _, self.temp_scale = self.create_slider(
            "", 2500, 5000, 100, bluelight_config['temperature'],
            bluelight_config['enabled'], temp_marks, self.on_temperature_changed
        )
        self.controls_box.append(slider_container)

    def on_toggle(self, switch, param):
        """Handle toggle switch"""
        state = switch.get_active()
        temperature = int(self.temp_scale.get_value())

        # Update slider sensitivity
        self.temp_scale.set_sensitive(state)

        # Apply change immediately
        if state:
            self.apply_temperature_change(temperature)
        else:
            self.disable_blue_light_filter()

        # Mark changes pending
        self.mark_changes_pending()

    def on_temperature_changed(self, scale):
        """Handle temperature change with snapping"""
        value = scale.get_value()
        # Snap to nearest 500K increment
        snapped_value = round(value / 500) * 500

        if abs(value - snapped_value) > 50:
            scale.set_value(snapped_value)
            return

        temperature = int(snapped_value)
        self.temp_label.set_markup(f'<span size="11000" alpha="75%">Temperature: {temperature}K</span>')

        # Apply temperature change immediately
        if self.switch.get_active():
            self.apply_temperature_change(temperature)

        # Mark changes pending
        self.mark_changes_pending()

    def apply_temperature_change(self, temperature):
        """Apply temperature change immediately to system and update config"""
        try:
            import subprocess
            import os
            import time

            # Kill any existing hyprsunset processes (ensure only one instance)
            subprocess.run(['pkill', '-f', 'hyprsunset'], check=False)
            # Wait a moment for processes to fully terminate
            time.sleep(0.1)
            # Start hyprsunset with new temperature as detached process
            subprocess.Popen(['hyprsunset', '-t', str(temperature)],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                           preexec_fn=os.setsid)

            # Update Hyprland config to make change persistent
            hyprland_config = Path.home() / '.config' / 'hypr' / 'hyprland.conf'
            if hyprland_config.exists():
                content = hyprland_config.read_text()
                # Replace hyprsunset line with new temperature
                content = re.sub(r'exec-once = hyprsunset -t \d+',
                               f'exec-once = hyprsunset -t {temperature}', content)
                hyprland_config.write_text(content)

            # Save to external config file for persistence
            self.save_bluelight_setting(True, temperature)
        except Exception as e:
            print(f"Blue light filter error: {e}")  # Debug output

    def disable_blue_light_filter(self):
        """Disable blue light filter immediately and update config"""
        try:
            import subprocess
            import re
            from pathlib import Path

            # Kill any existing hyprsunset processes (ensure complete shutdown)
            subprocess.run(['pkill', '-f', 'hyprsunset'], check=False)
            # Wait a moment for processes to fully terminate
            time.sleep(0.1)

            # Comment out hyprsunset line in Hyprland config
            hyprland_config = Path.home() / '.config' / 'hypr' / 'hyprland.conf'
            if hyprland_config.exists():
                content = hyprland_config.read_text()
                # Comment out the hyprsunset line
                content = re.sub(r'exec-once = hyprsunset -t \d+',
                               '# exec-once = hyprsunset -t 3500  # Disabled via Control Panel', content)
                hyprland_config.write_text(content)

            # Save to external config file for persistence
            self.save_bluelight_setting(False, 3500)
        except Exception as e:
            print(f"Blue light filter disable error: {e}")  # Debug output

    def save_bluelight_setting(self, enabled, temperature):
        """Save blue light setting to external config file for upgrade persistence"""
        try:
            import configparser
            import os
            from pathlib import Path

            config_file = Path.home() / '.config' / 'archriot' / 'archriot.conf'
            config = configparser.ConfigParser()

            # Read existing config if it exists
            if config_file.exists():
                config.read(config_file)

            # Ensure bluelight section exists
            if not config.has_section('bluelight'):
                config.add_section('bluelight')

            # Update bluelight settings
            config.set('bluelight', 'enabled', str(enabled).lower())
            config.set('bluelight', 'temperature', str(temperature))

            # Write back to file
            os.makedirs(config_file.parent, exist_ok=True)
            with open(config_file, 'w') as f:
                config.write(f)

        except Exception as e:
            print(f"Failed to save bluelight setting: {e}")

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        # All changes are already applied in real-time to system configs
        # No separate config file needed
        pass

class MullvadWidget(BaseControlWidget):
    """Mullvad VPN control widget"""

    def __init__(self, config, window=None):
        super().__init__(config, "Mullvad VPN", "Manage VPN connection and account settings", "🛡️")
        self.window = window
        self.setup_controls()

    def setup_controls(self):
        """Setup Mullvad VPN controls"""
        # Read directly from system - no config dependency
        current_account = self.get_current_mullvad_account()
        current_auto_connect = self.get_current_auto_connect_status()

        # Use actual system values
        account_number = current_account or ""
        actual_auto_connect = current_auto_connect if current_auto_connect is not None else False

        # Auto-connect label (add to title row)
        self.auto_connect_label = Gtk.Label()
        self.auto_connect_label.set_markup(f'<span size="11000" alpha="75%">Auto-connect: {"On" if actual_auto_connect else "Off"}</span>')
        self.auto_connect_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.auto_connect_label)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(actual_auto_connect)
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Account number entry
        account_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        account_label = Gtk.Label(label="Account Number:")
        account_label.set_halign(Gtk.Align.START)

        self.account_entry = Gtk.Entry()
        self.account_entry.set_placeholder_text("1234 5678 9012 3456")

        # Show account number privately (hidden by default)
        if account_number:
            self.account_entry.set_visibility(False)  # Hide by default
            self.account_entry.set_text(self.format_account_number(account_number))
            self.is_account_visible = False
        else:
            self.account_entry.set_text("")
            self.is_account_visible = True

        self.account_entry.set_max_length(19)
        self.account_entry.set_width_chars(25)
        self.account_entry.connect("changed", self.on_account_changed)
        self.account_entry.connect("activate", self.on_account_activate)

        account_box.append(account_label)
        account_box.append(self.account_entry)

        # Eye toggle button for show/hide
        self.eye_button = Gtk.Button()
        self.eye_button.set_size_request(40, -1)  # Set minimum width
        self.eye_button.set_halign(Gtk.Align.CENTER)
        self.update_eye_button()
        self.eye_button.connect("clicked", self.on_eye_toggle)
        account_box.append(self.eye_button)

        # Spacer to push button right
        spacer = Gtk.Box()
        spacer.set_hexpand(True)
        account_box.append(spacer)

        # Get Mullvad VPN button (same line, right-justified)
        link_button = Gtk.Button(label="Get Mullvad VPN")
        link_button.connect("clicked", self.on_get_mullvad_clicked)
        link_button.set_halign(Gtk.Align.END)
        account_box.append(link_button)

        self.controls_box.append(account_box)

    def on_toggle(self, switch, param):
        """Handle auto-connect toggle switch"""
        state = switch.get_active()
        account_number = self.account_entry.get_text()

        # Update label
        self.auto_connect_label.set_markup(f'<span size="11000" alpha="75%">Auto-connect: {"On" if state else "Off"}</span>')

        # Apply changes immediately to system
        self.apply_toggle_change(state, account_number)

        # Mark changes pending
        self.mark_changes_pending()

    def format_account_number(self, account_number):
        """Format account number with spaces every 4 digits"""
        # Remove any existing spaces
        clean = account_number.replace(' ', '')
        # Add spaces every 4 digits
        formatted = ' '.join(clean[i:i+4] for i in range(0, len(clean), 4))
        return formatted

    def on_account_changed(self, entry):
        """Handle account number input with auto-formatting"""
        text = entry.get_text()
        cursor_pos = entry.get_position()

        # Only allow digits and spaces
        filtered = ''.join(c for c in text if c.isdigit() or c == ' ')

        # Remove all spaces and re-format
        digits_only = ''.join(c for c in filtered if c.isdigit())

        # Limit to 16 digits
        if len(digits_only) > 16:
            digits_only = digits_only[:16]

        # Format with spaces
        formatted = self.format_account_number(digits_only)

        # Update field if changed
        if formatted != text:
            # Calculate new cursor position accounting for added spaces
            digits_before_cursor = len(''.join(c for c in text[:cursor_pos] if c.isdigit()))
            spaces_before_cursor = (digits_before_cursor - 1) // 4 if digits_before_cursor > 0 else 0
            new_pos = digits_before_cursor + spaces_before_cursor

            entry.set_text(formatted)
            entry.set_position(min(new_pos, len(formatted)))

    def on_account_activate(self, entry):
        """Handle account number validation when user presses Enter"""
        text = entry.get_text()
        clean_text = text.replace(' ', '')

        # Apply account change immediately
        self.apply_account_change(clean_text)

        # Mark changes pending
        self.mark_changes_pending()

    def get_current_mullvad_account(self):
        """Get current Mullvad account number from system"""
        try:
            import subprocess
            result = subprocess.run(['mullvad', 'account', 'get'], capture_output=True, text=True)
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'Mullvad account:' in line:
                        account = line.split(':')[1].strip()
                        return account
        except Exception:
            pass
        return None

    def get_current_auto_connect_status(self):
        """Get current auto-connect status from Mullvad"""
        try:
            import subprocess
            result = subprocess.run(['mullvad', 'auto-connect', 'get'], capture_output=True, text=True)
            if result.returncode == 0:
                return 'on' in result.stdout.lower()
        except Exception:
            pass
        return None

    def update_eye_button(self):
        """Update eye button appearance based on visibility state"""
        if hasattr(self, 'is_account_visible') and self.is_account_visible:
            self.eye_button.set_label("👁️")  # Open eye = visible
        else:
            self.eye_button.set_label("🔒")  # Lock = hidden

    def on_eye_toggle(self, button):
        """Toggle account number visibility"""
        self.is_account_visible = not self.is_account_visible
        self.account_entry.set_visibility(self.is_account_visible)
        self.update_eye_button()

    def apply_toggle_change(self, enabled, account_number):
        """Apply auto-connect toggle change immediately"""
        try:
            import subprocess
            from pathlib import Path

            # Set auto-connect
            if enabled:
                subprocess.run(['mullvad', 'auto-connect', 'set', 'on'], check=False)

                # Update Hyprland config to start Mullvad GUI
                hyprland_config = Path.home() / '.config' / 'hypr' / 'hyprland.conf'
                if hyprland_config.exists():
                    content = hyprland_config.read_text()
                    if 'exec-once = mullvad-vpn' not in content:
                        # Add Mullvad GUI to exec-once
                        content += '\nexec-once = mullvad-vpn\n'
                        hyprland_config.write_text(content)
            else:
                subprocess.run(['mullvad', 'auto-connect', 'set', 'off'], check=False)

                # Remove Mullvad GUI from Hyprland config
                hyprland_config = Path.home() / '.config' / 'hypr' / 'hyprland.conf'
                if hyprland_config.exists():
                    content = hyprland_config.read_text()
                    content = content.replace('exec-once = mullvad-vpn\n', '')
                    content = content.replace('\nexec-once = mullvad-vpn', '')
                    hyprland_config.write_text(content)
        except Exception as e:
            print(f"Mullvad toggle error: {e}")

    def apply_account_change(self, account_number):
        """Apply account login immediately"""
        try:
            import subprocess
            if account_number and len(account_number) >= 10:
                subprocess.run(['mullvad', 'account', 'login', account_number], check=False)
        except Exception as e:
            print(f"Mullvad account error: {e}")

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        # All changes are already applied in real-time to mullvad system
        # No separate config file needed - mullvad service is the source of truth
        pass

    def on_get_mullvad_clicked(self, button):
        """Open Mullvad VPN website"""
        import subprocess
        subprocess.Popen(['xdg-open', 'https://mullvad.net'])

class AudioWidget(BaseControlWidget):
    """Audio system control widget"""

    def __init__(self, config, window=None):
        super().__init__(config, "Audio", "PipeWire/PulseAudio configuration", "🔊")
        self.window = window
        self.setup_controls()

    def setup_controls(self):
        """Setup audio system controls"""
        # Get current audio system status
        current_status = self.get_audio_status()

        # Audio enabled label (add to title row)
        self.audio_label = Gtk.Label()
        self.audio_label.set_markup(f'<span size="11000" alpha="75%">Audio: {"On" if current_status else "Off"}</span>')
        self.audio_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.audio_label)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(current_status)
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

    def on_toggle(self, switch, param):
        """Handle audio system toggle switch"""
        state = switch.get_active()

        # Update label
        self.audio_label.set_markup(f'<span size="11000" alpha="75%">Audio: {"On" if state else "Off"}</span>')

        # Apply audio system change immediately
        self.apply_audio_change(state)

        # Mark changes pending
        self.mark_changes_pending()

    def get_audio_status(self):
        """Get current audio mute status"""
        try:
            import subprocess
            # Check if audio is muted using pactl
            result = subprocess.run(['pactl', 'get-sink-mute', '@DEFAULT_SINK@'],
                                  capture_output=True, text=True)
            if result.returncode == 0:
                return 'no' in result.stdout.lower()  # 'no' means not muted = audio on
            return True  # Default to on if we can't detect
        except Exception:
            return True  # Default to on if we can't detect

    def apply_audio_change(self, enabled):
        """Apply audio mute/unmute change immediately"""
        try:
            import subprocess
            if enabled:
                # Unmute audio
                subprocess.run(['pactl', 'set-sink-mute', '@DEFAULT_SINK@', '0'], check=False)
            else:
                # Mute audio
                subprocess.run(['pactl', 'set-sink-mute', '@DEFAULT_SINK@', '1'], check=False)
        except Exception as e:
            print(f"Audio mute error: {e}")

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        # Audio changes are already applied in real-time
        pass

class CameraWidget(BaseControlWidget):
    """Camera system control widget"""

    def __init__(self, config, window=None):
        super().__init__(config, "Camera", "Camera control and resolution settings", "📷")
        self.window = window
        self.setup_controls()

    def setup_controls(self):
        """Setup camera controls"""
        # Get current camera status and resolution
        current_status = self.get_camera_status()
        current_resolution = self.get_camera_resolution()

        # Resolution label (add to title row)
        self.resolution_label = Gtk.Label()
        self.resolution_label.set_markup(f'<span size="11000" alpha="75%">Resolution: {current_resolution}</span>')
        self.resolution_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.resolution_label)

        # Test Camera button (add to title row)
        test_button = Gtk.Button(label="Test Camera")
        test_button.connect("clicked", self.on_test_camera)
        test_button.set_sensitive(current_status)
        self.test_button = test_button
        self.title_row.append(test_button)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(current_status)
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Resolution slider
        self.available_resolutions = ["640x480", "960x540", "960x720", "1280x720", "1920x1080"]
        resolution_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        self.resolution_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 0, len(self.available_resolutions)-1, 1)

        # Set to current resolution
        current_index = 0
        for i, res in enumerate(self.available_resolutions):
            if res == current_resolution:
                current_index = i
                break

        self.resolution_scale.set_value(current_index)
        self.resolution_scale.set_draw_value(False)
        self.resolution_scale.set_sensitive(current_status)
        self.resolution_scale.connect("value-changed", self.on_resolution_changed)

        # Add margins to prevent text cutoff
        self.resolution_scale.set_margin_start(40)
        self.resolution_scale.set_margin_end(40)

        # Add tick marks
        for i, res in enumerate(self.available_resolutions):
            self.resolution_scale.add_mark(i, Gtk.PositionType.BOTTOM, res)

        resolution_box.append(self.resolution_scale)
        self.controls_box.append(resolution_box)

    def on_toggle(self, switch, param):
        """Handle camera toggle switch"""
        state = switch.get_active()

        # Update slider and test button sensitivity
        self.resolution_scale.set_sensitive(state)
        self.test_button.set_sensitive(state)

        # Apply camera change immediately
        self.apply_camera_change(state)

        # Mark changes pending
        self.mark_changes_pending()

    def on_resolution_changed(self, scale):
        """Handle resolution change with snapping"""
        value = scale.get_value()
        # Snap to nearest resolution index
        snapped_value = round(value)

        if abs(value - snapped_value) > 0.1:
            scale.set_value(snapped_value)
            return

        # Apply resolution change immediately
        index = int(snapped_value)
        if 0 <= index < len(self.available_resolutions):
            resolution = self.available_resolutions[index]
            self.resolution_label.set_markup(f'<span size="11000" alpha="75%">Resolution: {resolution}</span>')
            self.apply_resolution_change(resolution)

        # Mark changes pending
        self.mark_changes_pending()

    def on_test_camera(self, button):
        """Handle test camera button click"""
        self.show_camera_preview()

    def get_camera_status(self):
        """Get current camera device status"""
        try:
            import os
            # Check if camera devices exist and are accessible
            camera_devices = ['/dev/video0', '/dev/video1']
            for device in camera_devices:
                if os.path.exists(device) and os.access(device, os.R_OK):
                    return True
            return False
        except Exception:
            return False

    def get_camera_resolution(self):
        """Get current camera resolution"""
        try:
            import subprocess
            result = subprocess.run(['v4l2-ctl', '--get-fmt-video', '-d', '/dev/video0'], capture_output=True, text=True)
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'Width/Height' in line:
                        # Extract resolution from "Width/Height      : 960/720"
                        parts = line.split(':')[1].strip().split('/')
                        if len(parts) == 2:
                            width = parts[0].strip()
                            height = parts[1].strip()
                            return f"{width}x{height}"
            return "960x720"  # Default to current actual resolution
        except Exception:
            return "960x720"  # Default to current actual resolution

    def apply_camera_change(self, enabled):
        """Apply camera access change immediately"""
        try:
            import subprocess
            import os

            camera_devices = ['/dev/video0', '/dev/video1']

            if enabled:
                # Enable camera access by setting proper permissions
                for device in camera_devices:
                    if os.path.exists(device):
                        subprocess.run(['sudo', 'chmod', '666', device], check=False)
            else:
                # Disable camera access by removing permissions
                for device in camera_devices:
                    if os.path.exists(device):
                        subprocess.run(['sudo', 'chmod', '000', device], check=False)
        except Exception as e:
            print(f"Camera access error: {e}")

    def apply_resolution_change(self, resolution):
        """Apply camera resolution change immediately"""
        try:
            import subprocess
            width, height = resolution.split('x')
            # Set camera resolution using v4l2-ctl
            subprocess.run(['v4l2-ctl', '-d', '/dev/video0', '--set-fmt-video=width={},height={},pixelformat=MJPG'.format(width, height)], check=False)
        except Exception as e:
            print(f"Camera resolution error: {e}")

    def show_camera_preview(self):
        """Show simple GTK camera preview dialog"""
        try:
            import cv2
            import threading
            import time
            from gi.repository import GLib
            import numpy as np

            # Create camera preview dialog
            dialog = Gtk.Window()
            dialog.set_default_size(700, 600)
            dialog.set_modal(True)
            dialog.set_transient_for(self.window.window if self.window else None)
            dialog.add_css_class("archriot-control-panel")

            main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=20)
            main_box.set_margin_start(30)
            main_box.set_margin_end(30)
            main_box.set_margin_top(15)
            main_box.set_margin_bottom(20)

            # Header
            title_label = Gtk.Label()
            title_label.set_markup('<span size="28000" weight="bold" foreground="#bb9af7">📷 Camera Video Test</span>')
            title_label.set_halign(Gtk.Align.CENTER)
            main_box.append(title_label)

            # Content frame
            content_frame = Gtk.Frame()
            content_frame.set_margin_top(10)
            content_frame.add_css_class("archriot-control-panel")
            content_frame.set_vexpand(True)

            # Video display - fill the content frame completely
            self.camera_image = Gtk.Image()
            self.camera_image.set_hexpand(True)
            self.camera_image.set_vexpand(True)
            self.camera_image.set_halign(Gtk.Align.FILL)
            self.camera_image.set_valign(Gtk.Align.FILL)

            content_frame.set_child(self.camera_image)
            main_box.append(content_frame)

            # Close button
            close_button = Gtk.Button(label="Close")
            close_button.set_halign(Gtk.Align.CENTER)
            close_button.connect("clicked", lambda x: self.stop_camera_and_close(dialog))
            main_box.append(close_button)

            dialog.set_child(main_box)
            dialog.present()

            # Start camera feed
            self.camera_running = True
            self.camera_thread = threading.Thread(target=self.camera_feed_loop)
            self.camera_thread.daemon = True
            self.camera_thread.start()

        except ImportError:
            # Fallback if OpenCV not available
            content = "Camera preview requires OpenCV (python-opencv). Please install it:\n\nsudo pacman -S python-opencv"
            fallback_dialog = ArchRiotDialog("📷 Camera Preview", content, self.window.window if self.window else None)
            fallback_dialog.show()
        except Exception as e:
            print(f"Camera preview error: {e}")

    def stop_camera_and_close(self, dialog):
        """Stop camera and close dialog"""
        self.camera_running = False
        if hasattr(self, 'cap'):
            self.cap.release()
        dialog.close()

    def camera_feed_loop(self):
        """Camera feed loop running in background thread"""
        try:
            import cv2
            self.cap = cv2.VideoCapture(0)
            self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
            self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

            while self.camera_running:
                ret, frame = self.cap.read()
                if ret:
                    # Convert BGR to RGB
                    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

                    # Convert to GdkPixbuf
                    height, width, channels = frame_rgb.shape
                    pixbuf = GdkPixbuf.Pixbuf.new_from_data(
                        frame_rgb.tobytes(),
                        GdkPixbuf.Colorspace.RGB,
                        False,
                        8,
                        width,
                        height,
                        width * channels
                    )

                    # Update image on main thread
                    GLib.idle_add(self.update_camera_image, pixbuf)

                time.sleep(1/30)  # 30 FPS

            self.cap.release()
        except Exception as e:
            print(f"Camera feed error: {e}")

    def update_camera_image(self, pixbuf):
        """Update camera image on main thread"""
        if hasattr(self, 'camera_image'):
            self.camera_image.set_from_pixbuf(pixbuf)
        return False

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        # Camera changes are already applied in real-time
        pass

class DisplayWidget(BaseControlWidget):
    """Display settings control widget"""

    def __init__(self, config, window=None):
        super().__init__(config, "Display Settings", "Monitor configuration and scaling", "🖥️")
        self.window = window
        self.setup_controls()

    def get_available_resolutions(self):
        """Get available monitor resolutions with smart aspect ratio logic"""
        try:
            import subprocess
            import os
            from fractions import Fraction

            # Try hyprctl first
            result = subprocess.run(['hyprctl', 'monitors'], capture_output=True, text=True, timeout=5)
            current_resolution = "1920x1080"

            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    # Get current resolution from tab-indented line like "\t2560x1440@60.00100 at 0x0"
                    if '@' in line and 'x' in line and not 'availableModes:' in line:
                        if line.strip() and line.startswith('\t') and ' at ' in line:
                            try:
                                resolution_part = line.strip().split('@')[0]
                                if 'x' in resolution_part:
                                    current_resolution = resolution_part
                            except (ValueError, IndexError):
                                pass

            # Generate smart resolutions based on current resolution's aspect ratio
            try:
                width, height = map(int, current_resolution.split('x'))
                aspect_ratio = Fraction(width, height)

                # Common resolution sets by aspect ratio
                resolution_sets = {
                    Fraction(16, 9): ["3840x2160", "2560x1440", "1920x1080", "1600x900", "1366x768", "1280x720"],
                    Fraction(16, 10): ["3840x2400", "2560x1600", "1920x1200", "1680x1050", "1440x900", "1280x800"],
                    Fraction(4, 3): ["2048x1536", "1600x1200", "1400x1050", "1024x768", "800x600"],
                    Fraction(21, 9): ["3440x1440", "2560x1080"],  # Ultrawide
                    Fraction(32, 9): ["3840x1080"],  # Super ultrawide
                }

                # Find the closest matching aspect ratio
                best_match = min(resolution_sets.keys(),
                               key=lambda ratio: abs(float(ratio) - float(aspect_ratio)))

                # Get resolutions for this aspect ratio
                smart_resolutions = resolution_sets[best_match]

                # Filter to only include resolutions <= current resolution
                max_pixels = width * height
                filtered_resolutions = []
                for res in smart_resolutions:
                    res_width, res_height = map(int, res.split('x'))
                    if res_width * res_height <= max_pixels:
                        filtered_resolutions.append(res)

                # Ensure current resolution is included
                if current_resolution not in filtered_resolutions:
                    filtered_resolutions.insert(0, current_resolution)

                # Remove duplicates and limit to 5 options
                seen = set()
                unique_resolutions = []
                for res in filtered_resolutions:
                    if res not in seen:
                        seen.add(res)
                        unique_resolutions.append(res)

                return unique_resolutions[:5], current_resolution

            except (ValueError, IndexError):
                # Fallback if aspect ratio calculation fails
                pass

            # Final fallback - 16:9 resolutions
            return ["2560x1440", "1920x1080", "1600x900", "1366x768", "1280x720"], current_resolution

        except Exception as e:
            return ["1920x1080", "1600x900", "1366x768", "1280x720", "1024x768"], "1920x1080"

    def get_current_scaling(self):
        """Get current monitor scaling from hyprctl"""
        try:
            import subprocess
            result = subprocess.run(['hyprctl', 'monitors'], capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if line.strip().startswith('scale:'):
                        try:
                            scale_value = float(line.strip().split(':')[1].strip())
                            return int(scale_value * 100)  # Convert to percentage
                        except (ValueError, IndexError):
                            pass
            return 100  # Default to 100%
        except Exception:
            return 100

    def setup_controls(self):
        """Setup display settings controls"""
        # Read directly from system - no config dependency
        current_resolution = "1920x1080"
        current_scaling = 100
        enabled = True  # Display is always enabled if system is running

        # Get available resolutions and current resolution
        try:
            self.available_resolutions, current_resolution = self.get_available_resolutions()
        except Exception as e:
            self.available_resolutions, current_resolution = ["1920x1200", "1920x1080", "1680x1050", "1600x1200", "1440x900"], "1920x1080"

        # Get actual current scaling from system
        current_scaling = self.get_current_scaling()

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(enabled)
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Resolution slider
        resolution_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)


        # Create evenly spaced resolution scale (0 to 4 positions)

        # Ensure we have at least 2 resolutions for a valid slider range
        if len(self.available_resolutions) < 2:
            self.available_resolutions = ["1920x1200", "1920x1080", "1680x1050", "1600x1200", "1440x900"]
            current_resolution = "1920x1080"

        max_range = max(1, len(self.available_resolutions)-1)  # Ensure max is at least 1

        try:
            self.resolution_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 0, max_range, 1)
        except Exception as e:
            print(f"Failed to create resolution_scale: {e}")
            raise

        # Set to current resolution index
        current_index = 0
        for i, res in enumerate(self.available_resolutions):
            if res == current_resolution:
                current_index = i
                break


        try:
            self.resolution_scale.set_value(current_index)
        except Exception as e:
            print(f"Failed to set resolution_scale value: {e}")
            raise

        try:
            self.resolution_scale.set_draw_value(False)


            self.resolution_scale.set_sensitive(enabled)


            self.resolution_scale.set_margin_start(50)


            self.resolution_scale.set_margin_end(50)


            self.resolution_scale.connect("value-changed", self.on_resolution_changed)

        except Exception as e:
            raise

        # Add tick marks with actual available resolutions
        for i, resolution in enumerate(self.available_resolutions):
            # Convert "1920x1080" to "1920×1080" for display
            display_res = resolution.replace('x', '×')
            self.resolution_scale.add_mark(i, Gtk.PositionType.BOTTOM, display_res)

        resolution_box.append(self.resolution_scale)
        self.controls_box.append(resolution_box)

        # Scaling slider - all valid Hyprland scaling factors
        scaling_values = [100, 107, 120, 125, 150, 175, 200]  # 1.0, 1.066, 1.2, 1.25, 1.5, 1.75, 2.0
        scaling_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        self.scaling_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 100, 200, 1)
        self.scaling_scale.set_value(current_scaling)
        self.scaling_scale.set_draw_value(False)
        self.scaling_scale.set_sensitive(enabled)
        self.scaling_scale.connect("value-changed", self.on_scaling_changed)

        # Add scaling tick marks with proper labels
        scaling_labels = ["100%", "107%", "120%", "125%", "150%", "175%", "200%"]
        for i, scaling in enumerate(scaling_values):
            self.scaling_scale.add_mark(scaling, Gtk.PositionType.BOTTOM, scaling_labels[i])

        scaling_box.append(self.scaling_scale)
        self.controls_box.append(scaling_box)

    def snap_to_nearest(self, value, valid_values):
        """Snap value to nearest valid option"""
        return min(valid_values, key=lambda x: abs(x - value))

    def on_toggle(self, switch, param):
        """Handle toggle switch"""
        state = switch.get_active()

        # Update slider sensitivity
        self.resolution_scale.set_sensitive(state)
        self.scaling_scale.set_sensitive(state)

        # Mark changes pending
        self.mark_changes_pending()

    def on_resolution_changed(self, scale):
        """Handle resolution change with snapping"""
        value = scale.get_value()
        # Snap to nearest resolution index
        snapped_value = round(value)

        if abs(value - snapped_value) > 0.5:
            scale.set_value(snapped_value)
            return

        # Apply resolution change immediately
        index = int(snapped_value)
        if 0 <= index < len(self.available_resolutions):
            resolution = self.available_resolutions[index]
            self.apply_resolution_change(resolution)

        # Mark changes pending
        self.mark_changes_pending()

    def on_scaling_changed(self, scale):
        """Handle scaling change with snapping"""
        value = scale.get_value()
        snapped_value = self.snap_to_nearest(value, [100, 107, 120, 125, 150, 175, 200])

        if abs(value - snapped_value) > 0.5:
            scale.set_value(snapped_value)
            return

        # Apply scaling change immediately
        self.apply_scaling_change(int(snapped_value))

        # Mark changes pending
        self.mark_changes_pending()

    def apply_resolution_change(self, resolution):
        """Apply resolution change immediately to system"""
        try:
            import subprocess
            # Find current monitor - get the first active monitor
            result = subprocess.run(['hyprctl', 'monitors'], capture_output=True, text=True)
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for line in lines:
                    if line.startswith('Monitor ') and '(ID' in line:
                        monitor_name = line.split(' ')[1]
                        # Set resolution on this monitor using the full resolution string
                        subprocess.run(['hyprctl', 'keyword', 'monitor', f'{monitor_name},{resolution},0x0,1'], check=False)
                        break
        except Exception as e:
            print(f"Resolution change error: {e}")

    def apply_scaling_change(self, scaling):
        """Apply scaling change immediately to system"""
        try:
            import subprocess
            scale_factor = scaling / 100.0
            # Find current monitor and apply scaling
            result = subprocess.run(['hyprctl', 'monitors'], capture_output=True, text=True)
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for line in lines:
                    if line.startswith('Monitor ') and '(ID' in line:
                        monitor_name = line.split(' ')[1]
                        # Get current resolution from the monitor output
                        for monitor_line in lines:
                            if monitor_line.strip().startswith('2560x') or monitor_line.strip().startswith('1920x'):
                                current_res = monitor_line.strip().split('@')[0]
                                subprocess.run(['hyprctl', 'keyword', 'monitor', f'{monitor_name},{current_res},0x0,{scale_factor}'], check=False)
                                break
                        break
        except Exception:
            pass  # Silently fail if hyprctl is not available

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        # All changes are already applied in real-time to system via hyprctl
        # No separate config file needed - system state is the source of truth
        pass

class InputWidget(BaseControlWidget):
    """Input devices control widget"""

    def __init__(self, config):
        super().__init__(config, "Input Devices", "Keyboard/mouse/touchpad settings", "⌨️")
        self.setup_controls()

    def setup_controls(self):
        """Setup input devices controls"""
        placeholder = Gtk.Label()
        placeholder.set_markup('<span alpha="60%">Input device settings will be added here</span>')
        placeholder.set_margin_top(10)
        placeholder.set_margin_bottom(10)
        self.controls_box.append(placeholder)

class PowerWidget(BaseControlWidget):
    """Power management control widget"""

    def __init__(self, config, window=None):
        super().__init__(config, "Power Management", "Battery and performance profiles", "🔋")
        self.window = window
        self.setup_controls()

    def get_available_profiles(self):
        """Get available power profiles from powerprofilesctl"""
        # Standard profiles only
        standard_profiles = ['power-saver', 'balanced', 'performance']

        try:
            import subprocess
            result = subprocess.run(['powerprofilesctl', 'get'], capture_output=True, text=True)
            if result.returncode == 0:
                current_profile = result.stdout.strip()
                # Ensure current profile is in standard list
                if current_profile not in standard_profiles:
                    current_profile = 'balanced'
                return standard_profiles, current_profile
            return standard_profiles, 'balanced'  # fallback
        except Exception:
            return standard_profiles, 'balanced'  # fallback

    def setup_controls(self):
        """Setup power management controls"""
        power_config = self.config.get_power_config()

        # Get available profiles and current profile
        self.available_profiles, current_profile = self.get_available_profiles()

        # Use actual system profile, not config
        if current_profile in self.available_profiles:
            power_config['profile'] = current_profile

        # Profile label (add to title row)
        profile_names = ["Power Saver", "Balanced", "Performance"]
        current_index = 0
        for i, profile in enumerate(self.available_profiles):
            if profile == current_profile:
                current_index = i
                break
        self.profile_label = Gtk.Label()
        self.profile_label.set_markup(f'<span size="11000" alpha="75%">Profile: {profile_names[current_index]}</span>')
        self.profile_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.profile_label)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(power_config['enabled'])
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Power profile slider with icons
        self.available_profiles = ["power-saver", "balanced", "performance"]
        power_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        self.profile_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 0, len(self.available_profiles)-1, 1)

        # Set to current profile
        current_index = 0
        for i, profile in enumerate(self.available_profiles):
            if profile == current_profile:
                current_index = i
                break

        self.profile_scale.set_value(current_index)
        self.profile_scale.set_draw_value(False)
        self.profile_scale.set_sensitive(power_config['enabled'])
        self.profile_scale.set_margin_start(100)
        self.profile_scale.set_margin_end(100)
        self.profile_scale.connect("value-changed", self.on_profile_changed)

        # Add tick marks with correct icons
        self.profile_scale.add_mark(0, Gtk.PositionType.BOTTOM, "🐢 Power Saver")
        self.profile_scale.add_mark(1, Gtk.PositionType.BOTTOM, "⚖️ Balanced")
        self.profile_scale.add_mark(2, Gtk.PositionType.BOTTOM, "⚡ Performance")

        power_box.append(self.profile_scale)
        self.controls_box.append(power_box)

    def on_toggle(self, switch, param):
        """Handle toggle switch"""
        state = switch.get_active()

        # Update slider sensitivity
        self.profile_scale.set_sensitive(state)

        # Mark changes pending
        self.mark_changes_pending()

    def on_profile_changed(self, scale):
        """Handle profile change with snapping"""
        value = scale.get_value()
        # Snap to nearest profile index
        snapped_value = round(value)

        if abs(value - snapped_value) > 0.1:
            scale.set_value(snapped_value)
            return

        # Apply profile change immediately
        index = int(snapped_value)
        if 0 <= index < len(self.available_profiles):
            profile_names = ["Power Saver", "Balanced", "Performance"]
            self.profile_label.set_markup(f'<span size="11000" alpha="75%">Profile: {profile_names[index]}</span>')

            profile = self.available_profiles[index]
            try:
                import subprocess
                subprocess.run(['powerprofilesctl', 'set', profile], check=False)
            except Exception:
                pass

        # Mark changes pending
        self.mark_changes_pending()

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        enabled = self.switch.get_active()
        selected_index = int(self.profile_scale.get_value())
        profile = self.available_profiles[selected_index] if selected_index < len(self.available_profiles) else 'balanced'

        # Save to config
        self.config.set_power_config(enabled, profile)

        # Apply to system if enabled
        if enabled:
            try:
                import subprocess
                subprocess.run(['powerprofilesctl', 'set', profile], check=True)
            except Exception:
                pass  # Silently fail if powerprofilesctl is not available

class BackgroundWidget(BaseControlWidget):
    """Wallpaper management widget"""

    def __init__(self, config, parent_window):
        super().__init__(config, "Wallpaper Management", "Customize wallpapers and themes", "🎨")
        self.parent_window = parent_window
        self.backgrounds = []
        self.current_index = 0
        self.setup_controls()

    def setup_controls(self):
        """Setup background controls"""
        # Scan available backgrounds
        self.scan_backgrounds()

        # Current background label (add to title row)
        self.current_bg_label = Gtk.Label()
        self.current_bg_label.set_markup(f'<span size="11000" alpha="75%">Current: {self.get_current_background_name()}</span>')
        self.current_bg_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.current_bg_label)

        # Add custom background button (add to title row)
        add_bg_button = Gtk.Button(label="Add My Wallpaper")
        add_bg_button.connect("clicked", self.on_add_background)
        self.title_row.append(add_bg_button)

        # Dynamic theming toggle
        dynamic_theming_enabled = self.get_dynamic_theming_enabled()
        toggle_container, self.dynamic_toggle = self.create_toggle(
            "Dynamic Theming", dynamic_theming_enabled, self.on_dynamic_theming_changed
        )
        self.controls_box.append(toggle_container)

        # Background slider (using reusable function)
        if len(self.backgrounds) > 0:
            # Create marks with visual distinction for user backgrounds
            slider_marks = []
            system_count = len([bg for bg in self.backgrounds if 'riot_' in os.path.basename(bg)])

            for i in range(len(self.backgrounds)):
                mark_text = str(i + 1)
                if i >= system_count:  # User background
                    mark_text = f"U{i - system_count + 1}"
                slider_marks.append((i + 1, mark_text))

            slider_container, _, self.bg_slider = self.create_slider(
                "", 1, len(self.backgrounds), 1, self.current_index + 1, True,
                slider_marks, self.on_background_changed, snap_increment=1
            )
            self.controls_box.append(slider_container)

    def scan_backgrounds(self):
        """Scan for available background images"""
        import os
        import glob

        # System backgrounds
        system_bg_dir = os.path.expanduser("~/.local/share/archriot/backgrounds")
        user_bg_dir = os.path.expanduser("~/.config/archriot/backgrounds")

        system_backgrounds = []
        user_backgrounds = []

        # Scan system backgrounds
        if os.path.exists(system_bg_dir):
            patterns = ['*.jpg', '*.jpeg', '*.png', '*.webp']
            for pattern in patterns:
                system_backgrounds.extend(glob.glob(os.path.join(system_bg_dir, pattern)))

        # Scan user backgrounds
        if os.path.exists(user_bg_dir):
            patterns = ['*.jpg', '*.jpeg', '*.png', '*.webp']
            for pattern in patterns:
                user_backgrounds.extend(glob.glob(os.path.join(user_bg_dir, pattern)))

        # Sort each group separately with natural sorting, then combine: system first, user at end
        import re
        def natural_sort_key(text):
            return [int(c) if c.isdigit() else c.lower() for c in re.split(r'(\d+)', text)]

        system_backgrounds.sort(key=lambda x: natural_sort_key(os.path.basename(x)))
        user_backgrounds.sort(key=lambda x: natural_sort_key(os.path.basename(x)))
        self.backgrounds = system_backgrounds + user_backgrounds

        # Find current background index
        current_bg_file = os.path.expanduser("~/.config/archriot/.current-background")
        if os.path.exists(current_bg_file):
            try:
                with open(current_bg_file, 'r') as f:
                    current_bg = f.read().strip()
                if current_bg in self.backgrounds:
                    self.current_index = self.backgrounds.index(current_bg)
            except:
                pass

        # Save background preferences for upgrade preservation
        self.save_background_preferences()

    def get_current_background_name(self):
        """Get the name of current background"""
        if self.backgrounds and self.current_index < len(self.backgrounds):
            import os
            return os.path.basename(self.backgrounds[self.current_index])
        return "None"

    def on_background_changed(self, scale):
        """Handle background slider change"""
        new_index = int(scale.get_value()) - 1
        if 0 <= new_index < len(self.backgrounds):
            self.current_index = new_index
            self.apply_background_change()

    def on_add_background(self, button):
        """Handle add custom background button"""
        import os

        dialog = Gtk.FileChooserDialog(
            title="Select Background Image",
            action=Gtk.FileChooserAction.OPEN
        )
        dialog.set_transient_for(self.parent_window.window)
        dialog.set_modal(True)
        dialog.set_size_request(800, 700)

        dialog.add_buttons(
            "_Cancel", Gtk.ResponseType.CANCEL,
            "_Open", Gtk.ResponseType.OK
        )

        # Set default directory to Pictures
        pictures_dir = os.path.expanduser("~/Pictures")
        if os.path.exists(pictures_dir):
            pictures_file = Gio.File.new_for_path(pictures_dir)
            dialog.set_current_folder(pictures_file)

        # Add image file filters
        filter_images = Gtk.FileFilter()
        filter_images.set_name("Image files")
        filter_images.add_mime_type("image/jpeg")
        filter_images.add_mime_type("image/png")
        filter_images.add_mime_type("image/webp")
        filter_images.add_pattern("*.jpg")
        filter_images.add_pattern("*.jpeg")
        filter_images.add_pattern("*.png")
        filter_images.add_pattern("*.webp")
        dialog.set_filter(filter_images)

        dialog.connect("response", self.on_file_dialog_response)
        dialog.present()

    def on_file_dialog_response(self, dialog, response):
        """Handle file dialog response"""
        if response == Gtk.ResponseType.OK:
            file = dialog.get_file()
            if file:
                self.add_custom_background(file.get_path())
        dialog.destroy()

    def add_custom_background(self, file_path):
        """Add a custom background image"""
        import os
        import shutil

        # Create user backgrounds directory
        user_bg_dir = os.path.expanduser("~/.config/archriot/backgrounds")
        os.makedirs(user_bg_dir, exist_ok=True)

        # Get file extension
        _, ext = os.path.splitext(file_path)

        # Find next available user background number
        existing_files = [f for f in os.listdir(user_bg_dir) if f.startswith("user_")]
        next_num = len(existing_files) + 1

        # Copy file to user backgrounds directory
        dest_filename = f"user_{next_num:02d}{ext}"
        dest_path = os.path.join(user_bg_dir, dest_filename)

        try:
            shutil.copy2(file_path, dest_path)
            print(f"Added background: {dest_filename}")

            # Refresh background list and update UI
            self.refresh_backgrounds()

        except Exception as e:
            print(f"Error adding background: {e}")

    def refresh_backgrounds(self):
        """Refresh the background list and update slider"""
        old_count = len(self.backgrounds)
        self.scan_backgrounds()
        new_count = len(self.backgrounds)

        if new_count != old_count:
            # Remove old slider
            if hasattr(self, 'bg_slider') and self.bg_slider.get_parent():
                self.controls_box.remove(self.bg_slider.get_parent())

            # Create new slider with updated range (using reusable function)
            if len(self.backgrounds) > 0:
                # Create marks with visual distinction for user backgrounds
                bg_marks = []
                system_count = len([bg for bg in self.backgrounds if 'riot_' in os.path.basename(bg)])

                for i in range(len(self.backgrounds)):
                    mark_text = str(i + 1)
                    if i >= system_count:  # User background
                        mark_text = f"U{i - system_count + 1}"
                    bg_marks.append((i + 1, mark_text))

                slider_container, _, self.bg_slider = self.create_slider(
                    "", 1, len(self.backgrounds), 1, self.current_index + 1, True,
                    bg_marks, self.on_background_changed, snap_increment=1
                )
                self.controls_box.append(slider_container)

    def apply_background_change(self):
        """Apply the selected background"""
        if self.backgrounds and 0 <= self.current_index < len(self.backgrounds):
            import os
            import subprocess

            new_bg = self.backgrounds[self.current_index]

            # Update current background file
            current_bg_file = os.path.expanduser("~/.config/archriot/.current-background")
            try:
                os.makedirs(os.path.dirname(current_bg_file), exist_ok=True)
                with open(current_bg_file, 'w') as f:
                    f.write(new_bg)
            except:
                pass

            # Apply background via swaybg (with proper process detachment like swaybg-next)
            try:
                subprocess.run(['pkill', '-x', 'swaybg'], check=False)
                import time
                time.sleep(0.5)
                subprocess.Popen(['nohup', 'setsid', 'swaybg', '-i', new_bg, '-m', 'fill'],
                               stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                               preexec_fn=os.setsid)
            except:
                pass

            # Update theme colors if dynamic theming is enabled
            archriot_bin = os.path.expanduser("~/.local/share/archriot/install/archriot")
            if os.path.isfile(archriot_bin):
                try:
                    print(f"DEBUG: Calling theming system with path: {new_bg}")
                    result = subprocess.run([archriot_bin, '--apply-wallpaper-theme', new_bg],
                                 check=False, capture_output=True, text=True)
                    print(f"DEBUG: Theming command result: {result.returncode}")
                    if result.stdout:
                        print(f"DEBUG: stdout: {result.stdout}")
                    if result.stderr:
                        print(f"DEBUG: stderr: {result.stderr}")
                except Exception as e:
                    print(f"DEBUG: Exception calling theming system: {e}")

            # Update UI
            self.current_bg_label.set_markup(f'<span size="11000" alpha="75%">Current: {os.path.basename(new_bg)}</span>')

            # Save preferences after background change
            self.save_background_preferences()

    def save_background_preferences(self):
        """Save background preferences for upgrade preservation"""
        import json
        import os

        prefs_file = os.path.expanduser("~/.config/archriot/background-prefs.json")
        os.makedirs(os.path.dirname(prefs_file), exist_ok=True)

        current_bg = ""
        if self.backgrounds and 0 <= self.current_index < len(self.backgrounds):
            current_bg = os.path.basename(self.backgrounds[self.current_index])

        # Get list of user background filenames
        user_bg_dir = os.path.expanduser("~/.config/archriot/backgrounds")
        user_backgrounds = []
        if os.path.exists(user_bg_dir):
            user_backgrounds = [f for f in os.listdir(user_bg_dir)
                              if f.lower().endswith(('.jpg', '.jpeg', '.png', '.webp'))]

        preferences = {
            "current_background": current_bg,
            "user_backgrounds": user_backgrounds,
            "dynamic_theming": bool(getattr(self, 'dynamic_theming_enabled', False))
        }

        try:
            with open(prefs_file, 'w') as f:
                json.dump(preferences, f, indent=2)
        except Exception as e:
            print(f"Warning: Could not save background preferences: {e}")

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        self.parent_window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply any pending changes"""
        # Background changes are applied immediately
        pass

    def get_dynamic_theming_enabled(self):
        """Get the current dynamic theming setting"""
        import json
        import os

        prefs_file = os.path.expanduser("~/.config/archriot/background-prefs.json")
        if os.path.exists(prefs_file):
            try:
                with open(prefs_file, 'r') as f:
                    prefs = json.load(f)
                    return prefs.get("dynamic_theming", False)
            except:
                pass
        return False

    def on_dynamic_theming_changed(self, switch, state):
        """Handle dynamic theming toggle change"""
        import subprocess
        import os

        self.dynamic_theming_enabled = state

        # Call ArchRiot binary to toggle dynamic theming
        archriot_bin = os.path.expanduser("~/.local/share/archriot/install/archriot")
        if os.path.isfile(archriot_bin):
            try:
                subprocess.run([archriot_bin, '--toggle-dynamic-theming', str(state).lower()],
                             check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

                # Apply current wallpaper to trigger color update (static or dynamic)
                if self.backgrounds and 0 <= self.current_index < len(self.backgrounds):
                    current_bg = self.backgrounds[self.current_index]
                    subprocess.run([archriot_bin, '--apply-wallpaper-theme', current_bg],
                                 check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            except:
                pass

        # Save preferences
        self.save_background_preferences()

class SecurityWidget(BaseControlWidget):
    """Security control widget"""

    def __init__(self, config):
        super().__init__(config, "Security", "Firewall and security settings", "🛡️")
        self.setup_controls()

    def setup_controls(self):
        """Setup security controls"""
        placeholder = Gtk.Label()
        placeholder.set_markup('<span alpha="60%">Security settings will be added here</span>')
        placeholder.set_margin_top(10)
        placeholder.set_margin_bottom(10)
        self.controls_box.append(placeholder)

class ControlPanelWindow:
    """Main control panel window that assembles all widgets"""

    def __init__(self):
        # Initialize configuration
        self.config = ArchRiotConfig()

        # Initialize state tracking
        self.has_unsaved_changes = False



        # Create main window
        self.window = Gtk.Window()
        self.window.set_title("ArchRiot Control Panel")
        self.window.set_default_size(1000, 800)
        self.window.set_resizable(True)
        self.window.set_modal(True)
        self.window.add_css_class("archriot-control-panel")

        # Create main layout
        self.create_layout()

        # Connect window events
        self.window.connect("close-request", self.on_window_close)

    def create_layout(self):
        # Create the main window layout
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        main_box.set_margin_start(15)
        main_box.set_margin_end(15)
        main_box.set_margin_top(10)
        main_box.set_margin_bottom(15)

        # Header
        self.add_header(main_box)

        # Content area with widgets
        self.add_content_area(main_box)

        # Footer
        self.add_footer(main_box)

        self.window.set_child(main_box)

    def add_header(self, container):
        """Add header with title and version info"""
        header_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)

        # Main title with version
        version = self.get_archriot_version()
        title_label = Gtk.Label()
        title_label.set_markup(f'<span size="20000" weight="bold" foreground="#bb9af7">ArchRiot <span alpha="60%">v{version}</span> Control Panel</span>')
        title_label.set_halign(Gtk.Align.CENTER)
        header_box.append(title_label)

        container.append(header_box)

    def add_content_area(self, container):
        """Add main content area with control widgets"""
        # Create scrollable content
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        scrolled_window.set_vexpand(True)

        content_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        content_box.set_margin_start(20)
        content_box.set_margin_end(20)
        content_box.set_margin_top(10)
        content_box.set_margin_bottom(20)

        # Create and add widgets
        self.pomodoro_widget = PomodoroWidget(self.config, self)
        content_box.append(self.pomodoro_widget.widget)

        self.bluelight_widget = BlueLightWidget(self.config, self)
        content_box.append(self.bluelight_widget.widget)

        self.mullvad_widget = MullvadWidget(self.config, self)
        content_box.append(self.mullvad_widget.widget)

        # Audio widget removed - functionality not needed
        # self.audio_widget = AudioWidget(self.config, self)
        # content_box.append(self.audio_widget.widget)

        self.camera_widget = CameraWidget(self.config, self)
        content_box.append(self.camera_widget.widget)

        self.display_widget = DisplayWidget(self.config, self)
        content_box.append(self.display_widget.widget)

        # TODO: Re-enable these widgets later
        # self.input_widget = InputWidget(self.config)
        # content_box.append(self.input_widget.widget)

        self.power_widget = PowerWidget(self.config, self)
        content_box.append(self.power_widget.widget)

        self.background_widget = BackgroundWidget(self.config, self)
        content_box.append(self.background_widget.widget)

        # TODO: Re-enable these widgets later
        # self.security_widget = SecurityWidget(self.config)
        # content_box.append(self.security_widget.widget)

        scrolled_window.set_child(content_box)
        container.append(scrolled_window)

    def add_footer(self, container):
        """Add footer with action buttons"""
        # Footer removed - SUPER+Q handles window closing
        pass

    def apply_all_changes(self):
        """Apply all pending changes from all widgets"""
        if hasattr(self, 'pomodoro_widget') and hasattr(self.pomodoro_widget, 'apply_changes'):
            self.pomodoro_widget.apply_changes()
        if hasattr(self, 'bluelight_widget') and hasattr(self.bluelight_widget, 'apply_changes'):
            self.bluelight_widget.apply_changes()
        if hasattr(self, 'mullvad_widget') and hasattr(self.mullvad_widget, 'apply_changes'):
            self.mullvad_widget.apply_changes()
        # Audio widget removed
        # if hasattr(self, 'audio_widget') and hasattr(self.audio_widget, 'apply_changes'):
        #     self.audio_widget.apply_changes()
        if hasattr(self, 'camera_widget') and hasattr(self.camera_widget, 'apply_changes'):
            self.camera_widget.apply_changes()
        if hasattr(self, 'display_widget') and hasattr(self.display_widget, 'apply_changes'):
            self.display_widget.apply_changes()
        # TODO: Re-enable these widgets later
        # if hasattr(self, 'input_widget') and hasattr(self.input_widget, 'apply_changes'):
        #     self.input_widget.apply_changes()
        if hasattr(self, 'power_widget') and hasattr(self.power_widget, 'apply_changes'):
            self.power_widget.apply_changes()
        # TODO: Re-enable these widgets later
        # if hasattr(self, 'security_widget') and hasattr(self.security_widget, 'apply_changes'):
        #     self.security_widget.apply_changes()

        self.has_unsaved_changes = False
        print("All changes applied!")



    def on_window_close(self, window):
        """Handle window close request"""
        if hasattr(self, 'app'):
            self.app.quit()
        return False





    def get_archriot_version(self):
        """Read ArchRiot version from VERSION file"""
        home_dir = Path.home()
        version_path = home_dir / '.local' / 'share' / 'archriot' / 'VERSION'

        try:
            with open(version_path, 'r') as f:
                version = f.read().strip()
                return version
        except Exception:
            return "unknown"

class ControlPanelApplication(Gtk.Application):
    """GTK Application wrapper"""

    def __init__(self):
        super().__init__(application_id="net.archriot.control-panel")

    def do_activate(self):
        """Activate the application"""
        if not self.get_windows():
            window = ControlPanelWindow()
            window.app = self
            self.add_window(window.window)

        # Apply CSS styling
        self.apply_css()

        # Show the window
        self.get_windows()[0].present()

    def apply_css(self):
        """Apply ArchRiot theming"""
        css_provider = Gtk.CssProvider()
        css_data = """
        * {
            font-family: "Hack Nerd Font Mono", "Hack Nerd Font", monospace;
        }

        window {
            background: rgba(0, 0, 0, 1.0);
            color: #cdd6f4;
            font-family: "Hack Nerd Font Mono", "Hack Nerd Font", monospace;
        }

        label {
            color: #cdd6f4;
            font-family: "Hack Nerd Font Mono", "Hack Nerd Font", monospace;
        }

        frame {
            border: 1px solid rgba(157, 123, 216, 0.3);
            border-radius: 8px;
        }



        button {
            background: rgba(75, 0, 130, 1.0);
            color: #ffffff;
            border: none;
            border-radius: 6px;
            padding: 4px 12px;
            font-weight: bold;
            min-height: 24px;
            font-family: "Hack Nerd Font Mono", "Hack Nerd Font", monospace;
        }

        button:hover {
            background: rgba(102, 51, 153, 1.0);
        }



        entry {
            background: rgba(20, 21, 31, 0.9);
            color: #cdd6f4;
            border: 1px solid rgba(157, 123, 216, 0.3);
            border-radius: 6px;
            min-height: 24px;
            padding: 4px 8px;
        }

        entry:focus {
            border: 1px solid rgba(187, 154, 247, 0.6);
        }

        scrolledwindow {
            border: none;
            background: rgba(0, 0, 0, 0.7);
        }
        """

        css_provider.load_from_data(css_data.encode())

        # Apply CSS to default display
        display = Gdk.Display.get_default()
        Gtk.StyleContext.add_provider_for_display(
            display,
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_USER
        )

def main():
    """Main entry point"""
    import argparse

    parser = argparse.ArgumentParser(description='ArchRiot Control Panel')
    parser.add_argument('--reapply', action='store_true',
                       help='Re-apply saved settings to fresh config files')

    args = parser.parse_args()

    if args.reapply:
        reapply_saved_settings()
        return 0

    app = ControlPanelApplication()
    return app.run(sys.argv)

def reapply_saved_settings():
    """Re-apply all saved user settings to fresh config files"""
    try:
        # Import config module to read saved settings
        config_class = import_config_module()
        if not config_class:
            return

        # Create config instance
        config = config_class()

        # Re-apply blue light filter setting
        bluelight_config = config.get_bluelight_config()

        if bluelight_config['enabled'] and bluelight_config['temperature'] != 3500:
            apply_bluelight_setting(bluelight_config['temperature'])
            print(f"Re-applied blue light filter: {bluelight_config['temperature']}K")
        elif not bluelight_config['enabled']:
            disable_bluelight_setting()
            print("Re-applied blue light filter: disabled")

        # TODO: Add other settings re-application here as needed

    except Exception as e:
        print(f"Error re-applying settings: {e}")

def apply_bluelight_setting(temperature):
    """Apply blue light temperature setting to hyprland.conf"""
    import re
    from pathlib import Path

    hyprland_config = Path.home() / '.config' / 'hypr' / 'hyprland.conf'
    if hyprland_config.exists():
        content = hyprland_config.read_text()
        content = re.sub(r'exec-once = hyprsunset -t \d+',
                        f'exec-once = hyprsunset -t {temperature}', content)
        hyprland_config.write_text(content)

def disable_bluelight_setting():
    """Disable blue light filter in hyprland.conf"""
    import re
    from pathlib import Path

    hyprland_config = Path.home() / '.config' / 'hypr' / 'hyprland.conf'
    if hyprland_config.exists():
        content = hyprland_config.read_text()
        content = re.sub(r'exec-once = hyprsunset -t \d+',
                        '# exec-once = hyprsunset -t 3500  # Disabled via Control Panel', content)
        hyprland_config.write_text(content)

if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)
