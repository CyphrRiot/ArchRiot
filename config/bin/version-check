#!/usr/bin/env python3

import os
import sys
import json
import subprocess
import urllib.request
import urllib.error
from datetime import datetime, timezone
import re
import textwrap
import difflib

# GTK imports for direct dialog integration
import gi

gi.require_version("Gtk", "3.0")
gi.require_version("Gdk", "3.0")
from gi.repository import Gtk, Gdk, GLib, Pango


# Shared utility functions
def load_css_styling(config_dir):
    """Load CSS styling from file or return default embedded styles"""
    default_css = """
        * {
            font-family: "Paper Mono", "Symbols Nerd Font", "Symbols Nerd Font Mono", monospace;
        }

        window {
            background: #1a1b26;
            color: #cdd6f4;
            font-family: "Paper Mono", "Symbols Nerd Font", "Symbols Nerd Font Mono", monospace;
        }

        label {
            color: #cdd6f4;
            font-family: "Paper Mono", "Symbols Nerd Font", "Symbols Nerd Font Mono", monospace;
        }

        textview {
            background: #1a1b26;
            color: #cdd6f4;
            border: none;
            font-family: "Paper Mono", "Symbols Nerd Font", "Symbols Nerd Font Mono", monospace;
        }

        textview text {
            background: #1a1b26;
            color: #cdd6f4;
            font-family: "Paper Mono", "Symbols Nerd Font", "Symbols Nerd Font Mono", monospace;
        }

        button {
            background: rgba(75, 0, 130, 1.0);
            color: #ffffff;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-weight: bold;
            font-family: "Paper Mono", "Symbols Nerd Font", "Symbols Nerd Font Mono", monospace;
        }

        button:hover {
            background: rgba(102, 51, 153, 1.0);
        }

        scrolledwindow {
            border: none;
            background: #1a1b26;
        }
        """

    # Try to load from external file first
    if config_dir:
        css_file = os.path.join(config_dir, "dialog-style.css")
        try:
            if os.path.exists(css_file):
                with open(css_file, "r") as f:
                    custom_css = f.read()
                    log_with_timestamp(
                        f"Loaded custom CSS from {css_file}", "INFO", config_dir
                    )
                    return custom_css
        except Exception as e:
            log_with_timestamp(
                f"Error loading custom CSS file: {e}, using default",
                "WARNING",
                config_dir,
            )

    return default_css


def log_with_timestamp(message, level="INFO", config_dir=None):
    """Log message with timestamp and optional file logging"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_message = f"[{timestamp}] {level}: {message}"
    print(log_message)

    # Also log to unified runtime log for persistent debugging
    try:
        cache_dir = os.path.join(os.path.expanduser("~"), ".cache", "archriot")
        os.makedirs(cache_dir, exist_ok=True)
        log_file = os.path.join(cache_dir, "runtime.log")
        with open(log_file, "a") as f:
            f.write("[version-check] " + log_message + "\n")
    except Exception:
        pass  # Don't let logging errors break the application


def load_config(config_file):
    """Load version check configuration"""
    default_config = {
        "ignore_notifications": False,
        "last_check": None,
        "last_notified_version": None,
        "check_interval_hours": 4,
    }

    if not os.path.exists(config_file):
        return default_config

    try:
        with open(config_file, "r") as f:
            config = json.load(f)
            # Merge with defaults to handle missing keys
            for key, value in default_config.items():
                if key not in config:
                    config[key] = value
            return config
    except Exception as e:
        log_with_timestamp(f"Error loading config: {e}", "ERROR")
        return default_config


def save_config(config_file, config_dir, config):
    """Save version check configuration"""
    try:
        os.makedirs(config_dir, exist_ok=True)
        with open(config_file, "w") as f:
            json.dump(config, f, indent=2)
    except Exception as e:
        log_with_timestamp(f"Error saving config: {e}", "ERROR")


class UpdateDialog:
    """Handles the GUI dialog for displaying update information and user interactions."""

    def __init__(
        self, local_version, remote_version, commit_messages=None, disable_timeout=False
    ):
        self.local_version = local_version
        self.remote_version = remote_version
        self.commit_messages = commit_messages or []
        self.disable_timeout = disable_timeout
        self.home_dir = os.path.expanduser("~")
        self.config_dir = os.path.join(self.home_dir, ".config", "archriot")
        self.config_file = os.path.join(self.config_dir, "versions.cfg")
        self.lock_file = "/tmp/archriot_upgrade.lock"
        self.user_interacted = False  # Track if user actually interacted with dialog
        self.dialog_timeout_id = None  # Track timeout for visibility check

        # Create lock file - exit if another instance is running
        if not self.create_lock_file():
            print("Another version check dialog is already running. Exiting.")
            sys.exit(0)

        self.window = Gtk.Window()
        self.window.set_title("ArchRiot Update Available")
        self.window.set_default_size(500, 350)
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.set_resizable(False)

        # Make window modal and keep above
        self.window.set_modal(True)
        self.window.set_keep_above(True)
        self.window.set_type_hint(Gdk.WindowTypeHint.DIALOG)

        # Force window to be urgent and demand attention
        self.window.set_urgency_hint(True)
        self.window.present()

        # Create main container
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=20)
        main_box.set_margin_start(40)
        main_box.set_margin_end(40)
        main_box.set_margin_top(30)
        main_box.set_margin_bottom(30)

        # Add title
        self.add_title(main_box)

        # Add version information
        self.add_version_info(main_box)

        # Add update instructions
        self.add_instructions(main_box)

        # Add buttons
        self.add_buttons(main_box)

        self.window.add(main_box)
        self.window.connect("destroy", self.on_window_destroy)

        # Set up CSS for styling (same as original dialog)
        self.setup_styling()

        self.window.show_all()

        # Log dialog creation for debugging
        log_with_timestamp(
            f"Dialog created for update {local_version} -> {remote_version}",
            "DIALOG",
            self.config_dir,
        )

        # Set up timeout to check if dialog is actually visible to user
        # Skip timeout if explicitly disabled (for GUI mode)
        if not self.disable_timeout:
            # If no interaction after 5 minutes, send fallback notification
            self.dialog_timeout_id = GLib.timeout_add_seconds(
                300, self.on_dialog_timeout
            )
        else:
            self.dialog_timeout_id = None
            log_with_timestamp(
                "Timeout disabled for explicit GUI mode", "DIALOG", self.config_dir
            )

    def create_lock_file(self):
        """Create lock file with PID and cleanup handling using atomic operations"""
        try:
            # Clean up stale lock files first
            if os.path.exists(self.lock_file):
                try:
                    with open(self.lock_file, "r") as f:
                        old_pid = f.read().strip()

                    # Check if the process is still running
                    if old_pid.isdigit() and not os.path.exists(f"/proc/{old_pid}"):
                        os.remove(self.lock_file)
                    elif os.path.exists(f"/proc/{old_pid}"):
                        print(f"Another instance is already running (PID: {old_pid})")
                        return False
                except (ValueError, OSError):
                    # If we can't read the PID or it's invalid, remove the stale lock
                    try:
                        os.remove(self.lock_file)
                    except OSError:
                        pass

            # Try to create lock file atomically using exclusive creation
            try:
                # Use os.open with O_CREAT|O_EXCL for atomic creation
                import fcntl

                fd = os.open(
                    self.lock_file, os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644
                )
                with os.fdopen(fd, "w") as f:
                    f.write(str(os.getpid()))
                return True
            except FileExistsError:
                print("Another instance is already running (lock file exists)")
                return False

        except Exception as e:
            log_with_timestamp(
                f"Could not create lock file: {e}", "WARNING", self.config_dir
            )
            return False

    def cleanup_lock_file(self):
        """Clean up lock file on exit"""
        try:
            if os.path.exists(self.lock_file):
                os.remove(self.lock_file)
        except Exception:
            pass

    def clear_waybar_state(self):
        """Clear waybar update state files"""
        try:
            update_flag_file = os.path.join(self.config_dir, "update_available")
            update_state_file = os.path.join(self.config_dir, "update_state")

            if os.path.exists(update_flag_file):
                os.remove(update_flag_file)
            if os.path.exists(update_state_file):
                os.remove(update_state_file)
        except Exception as e:
            log_with_timestamp(
                f"Could not clear waybar state: {e}", "WARNING", self.config_dir
            )

    def add_title(self, container):
        """Add main title"""
        title_label = Gtk.Label()
        title_label.set_markup(
            '<span size="24000" weight="bold">â—† Update Available â—†</span>'
        )
        title_label.set_halign(Gtk.Align.CENTER)
        title_label.set_margin_bottom(10)
        container.pack_start(title_label, False, False, 0)

    def add_version_info(self, container):
        """Add version comparison information"""
        version_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        version_box.set_halign(Gtk.Align.CENTER)

        version_label = Gtk.Label()
        version_label.set_markup(
            f'<span size="14000">Update: <b>{self.local_version}</b> â†’ <b><span foreground="#89b4fa">v{self.remote_version}</span></b></span>'
        )
        version_label.set_halign(Gtk.Align.CENTER)
        version_box.pack_start(version_label, False, False, 0)

        container.pack_start(version_box, False, False, 0)

    def add_instructions(self, container):
        """Add update instructions with dynamic commit messages"""
        instructions_label = Gtk.Label()

        # Build dynamic content based on commit messages
        if self.commit_messages:
            # Format commit messages using textwrap for proper handling
            formatted_messages = []
            for msg in self.commit_messages[:8]:
                # Handle multi-line commit messages properly
                msg_lines = msg.split("\n")
                formatted_msg_lines = []

                for i, line in enumerate(msg_lines):
                    if i == 0:
                        # First line gets bullet point with hanging indent
                        wrapped = textwrap.fill(
                            f"â€¢ {line}", width=50, subsequent_indent="  "
                        )
                        formatted_msg_lines.append(wrapped)
                    else:
                        # Subsequent lines get hanging indent
                        if line.strip():  # Only wrap non-empty lines
                            wrapped = textwrap.fill(
                                f"  {line}", width=50, subsequent_indent="  "
                            )
                            formatted_msg_lines.append(wrapped)
                        else:
                            formatted_msg_lines.append("  ")

                formatted_messages.append("\n".join(formatted_msg_lines))

            changes_text = "\n\n".join(formatted_messages)
            instructions_text = f"""Recent Changes:\n
{changes_text}

The update process will backup your configuration and preserve your settings.

This dialog is non-blocking; you can continue working while it's open.
Logs: ~/.cache/archriot/runtime.log

Choose an option below to proceed."""
        else:
            # Fallback to static message if no commit messages available
            instructions_text = f"""The update process will:

    â€¢ Download the latest ArchRiot setup script
    â€¢ Backup your current configuration
    â€¢ Update system files and scripts
    â€¢ Preserve your personal settings

Logs: ~/.cache/archriot/runtime.log
Note: This dialog is non-blocking; you can continue working while it's open.

Choose an option below to proceed."""

        instructions_label.set_text(instructions_text)
        instructions_label.set_line_wrap(True)
        instructions_label.set_line_wrap_mode(Pango.WrapMode.WORD)
        instructions_label.set_max_width_chars(60)
        instructions_label.set_halign(Gtk.Align.START)
        instructions_label.set_valign(Gtk.Align.CENTER)
        instructions_label.set_justify(Gtk.Justification.LEFT)
        instructions_label.set_margin_start(20)
        instructions_label.set_margin_end(20)
        instructions_label.set_margin_top(15)
        instructions_label.set_margin_bottom(15)

        # Set font using CSS styling (modern approach)
        css_provider = Gtk.CssProvider()
        css_provider.load_from_data(b"""
        label {
            font-family: "Paper Mono", "Symbols Nerd Font", "Symbols Nerd Font Mono", monospace;
            font-size: 14px;
        }
        """)
        style_context = instructions_label.get_style_context()
        style_context.add_provider(
            css_provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

        # Wrap in scrolled window to handle tall content
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        scrolled_window.set_max_content_height(200)
        scrolled_window.set_propagate_natural_height(True)
        scrolled_window.add(instructions_label)

        container.pack_start(scrolled_window, True, True, 0)

    def add_buttons(self, container):
        """Add action buttons"""
        # Create button box
        button_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=15)
        button_box.set_halign(Gtk.Align.CENTER)
        button_box.set_margin_top(10)

        # Install button
        install_button = Gtk.Button(label="ðŸ“¥ Install")
        install_button.connect("clicked", self.on_install_clicked)
        install_button.set_size_request(120, 40)
        button_box.pack_start(install_button, False, False, 0)

        # Ignore Notifications button
        ignore_button = Gtk.Button(label="ðŸ”• Ignore Notifications")
        ignore_button.connect("clicked", self.on_ignore_clicked)
        ignore_button.set_size_request(160, 40)
        button_box.pack_start(ignore_button, False, False, 0)

        # Close button
        close_button = Gtk.Button(label="âŒ Close")
        close_button.connect("clicked", self.on_close_clicked)
        close_button.set_size_request(100, 40)
        button_box.pack_start(close_button, False, False, 0)

        container.pack_start(button_box, False, False, 0)

    def on_install_clicked(self, button):
        """Handle install button click - open terminal and run update command"""
        self.user_interacted = True  # Mark that user interacted
        log_with_timestamp("User clicked Install button", "DIALOG", self.config_dir)

        # Cancel timeout since user interacted
        if self.dialog_timeout_id:
            GLib.source_remove(self.dialog_timeout_id)
            self.dialog_timeout_id = None

        # Clear waybar state file if managed by waybar
        if hasattr(self, "waybar_managed") and self.waybar_managed:
            self.clear_waybar_state()
        try:
            # Persisted choice + Local vs cURL upgrade path selection
            cfg = self.load_config()
            last_choice = cfg.get("upgrade_source", "curl")

            choice_dialog = Gtk.MessageDialog(
                transient_for=self.window,
                flags=0,
                message_type=Gtk.MessageType.INFO,
                buttons=Gtk.ButtonsType.NONE,
                message_format="Choose upgrade source",
            )
            choice_dialog.format_secondary_text(
                "Install from cURL: uses maintainer packages.yaml (may reintroduce removed packages)\n"
                "Install from Local: uses your local packages.yaml and respects removed packages.\n\n"
                f"Last choice: {last_choice.upper()}"
            )
            choice_dialog.add_button("ðŸŒ Install from cURL", Gtk.ResponseType.YES)
            choice_dialog.add_button("ðŸ“ Install from Local", Gtk.ResponseType.APPLY)
            choice_dialog.add_button("ðŸ§¾ View Diff", Gtk.ResponseType.NO)
            choice_dialog.add_button("Cancel", Gtk.ResponseType.CANCEL)

            if last_choice == "local":
                choice_dialog.set_default_response(Gtk.ResponseType.APPLY)
            else:
                choice_dialog.set_default_response(Gtk.ResponseType.YES)

            response = choice_dialog.run()
            choice_dialog.destroy()

            if (
                response == Gtk.ResponseType.CANCEL
                or response == Gtk.ResponseType.DELETE_EVENT
            ):
                return

            if response == Gtk.ResponseType.NO:
                # Show a unified diff between local and maintainer packages.yaml
                try:
                    local_path = os.path.join(
                        self.home_dir,
                        ".local",
                        "share",
                        "archriot",
                        "install",
                        "packages.yaml",
                    )
                    try:
                        with open(local_path, "r") as f:
                            local_text = f.read()
                    except Exception as e:
                        local_text = ""
                    # Fetch remote maintainer packages.yaml
                    url = "https://raw.githubusercontent.com/CyphrRiot/ArchRiot/master/install/packages.yaml"
                    req = urllib.request.Request(
                        url, headers={"User-Agent": "ArchRiot-VersionChecker/1.0"}
                    )
                    with urllib.request.urlopen(req, timeout=10) as resp:
                        remote_text = resp.read().decode("utf-8")
                    diff_lines = difflib.unified_diff(
                        local_text.splitlines(),
                        remote_text.splitlines(),
                        fromfile="local packages.yaml",
                        tofile="maintainer packages.yaml",
                        lineterm="",
                    )
                    diff_text = "\n".join(diff_lines)
                    if not diff_text:
                        diff_text = "No differences detected between local and maintainer packages.yaml."
                    # Show diff in a scrollable dialog
                    dialog = Gtk.Dialog(
                        title="packages.yaml Diff", transient_for=self.window, flags=0
                    )
                    dialog.set_default_size(700, 500)
                    content = dialog.get_content_area()
                    sw = Gtk.ScrolledWindow()
                    sw.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
                    tv = Gtk.TextView()
                    tv.set_editable(False)
                    tv.set_monospace(True)
                    tv.get_buffer().set_text(diff_text)
                    sw.add(tv)
                    content.add(sw)
                    dialog.add_button("Close", Gtk.ResponseType.CLOSE)
                    dialog.show_all()
                    dialog.run()
                    dialog.destroy()
                except Exception as e:
                    err_dialog = Gtk.MessageDialog(
                        transient_for=self.window,
                        flags=0,
                        message_type=Gtk.MessageType.ERROR,
                        buttons=Gtk.ButtonsType.CLOSE,
                        message_format="Failed to compute diff",
                    )
                    err_dialog.format_secondary_text(str(e))
                    err_dialog.run()
                    err_dialog.destroy()
                return

            # Compute update command based on choice and persist it
            if response == Gtk.ResponseType.APPLY:
                # Local: respect user's local packages.yaml and do not reintroduce removed packages
                # Run Local upgrade smoke test to ensure removed packages are not reintroduced
                try:
                    binary_path = os.path.join(
                        self.home_dir,
                        ".local",
                        "share",
                        "archriot",
                        "install",
                        "archriot",
                    )
                    if os.path.exists(binary_path) and os.access(binary_path, os.X_OK):
                        res = subprocess.run(
                            [binary_path, "--upgrade-smoketest", "--quiet"],
                            capture_output=True,
                            text=True,
                        )
                        if res.returncode == 2:
                            err_text = (
                                res.stdout.strip()
                                or "Local upgrade smoke test detected potential reintroductions. Edit your local packages.yaml or use the cURL path."
                            )
                            err_dialog = Gtk.MessageDialog(
                                transient_for=self.window,
                                flags=0,
                                message_type=Gtk.MessageType.ERROR,
                                buttons=Gtk.ButtonsType.CLOSE,
                                message_format="Local upgrade blocked by smoke test",
                            )
                            err_dialog.format_secondary_text(err_text[:4000])
                            err_dialog.run()
                            err_dialog.destroy()
                            return
                except Exception as e:
                    # Non-fatal: proceed with Local path if smoketest is unavailable or errors
                    pass
                update_command = 'if [ -x "$HOME/.local/share/archriot/install/archriot" ]; then "$HOME/.local/share/archriot/install/archriot" --validate && "$HOME/.local/share/archriot/install/archriot"; else echo "Local installer not found at ~/.local/share/archriot/install/archriot"; fi'
                cfg["upgrade_source"] = "local"
                self.save_config(cfg)
            else:
                # cURL: maintainerâ€™s package set (current behavior)
                update_command = "curl https://ArchRiot.org/setup.sh | bash"
                cfg["upgrade_source"] = "curl"
                self.save_config(cfg)

            # Use hyprctl dispatch to launch terminal EXACTLY like SUPER+SHIFT+ENTER
            # Change to home directory first to avoid getcwd errors
            terminal_cmd = f'ghostty --class=com.mitchellh.ghostty-floating -e bash -c \'cd $HOME; echo "Starting ArchRiot update..."; {update_command}; echo "Update complete. Press Enter to close."; read\''

            try:
                # Use hyprctl dispatch exec to launch exactly like SUPER+SHIFT+ENTER
                result = subprocess.run(
                    ["hyprctl", "dispatch", "exec", terminal_cmd],
                    capture_output=True,
                    text=True,
                    timeout=10,
                )

                if result.returncode == 0:
                    print("Successfully launched update terminal via hyprctl dispatch")
                else:
                    raise Exception(f"hyprctl dispatch failed: {result.stderr}")
            except Exception as e:
                raise Exception(f"Failed to launch terminal via hyprctl: {e}")

            # Keep dialog open briefly to show success
            print("Update terminal launched successfully")
            GLib.timeout_add_seconds(
                2, lambda: (self.cleanup_lock_file(), Gtk.main_quit())
            )

        except Exception as e:
            log_with_timestamp(f"Error launching update: {e}", "ERROR", self.config_dir)

    def on_ignore_clicked(self, button):
        """Handle ignore notifications button click"""
        self.user_interacted = True  # Mark that user interacted
        log_with_timestamp("User clicked Ignore button", "DIALOG", self.config_dir)

        # Cancel timeout since user interacted
        if self.dialog_timeout_id:
            GLib.source_remove(self.dialog_timeout_id)
            self.dialog_timeout_id = None
        try:
            config = load_config(self.config_file)
            config["ignore_notifications"] = True
            save_config(self.config_file, self.config_dir, config)

            dialog = Gtk.MessageDialog(
                transient_for=self.window,
                flags=0,
                message_type=Gtk.MessageType.INFO,
                buttons=Gtk.ButtonsType.OK,
                message_format="Notifications Disabled",
            )
            dialog.format_secondary_text(
                "Future update notifications have been disabled.\n\nYou can re-enable them by running:\nversion-check --reset"
            )
            dialog.run()
            dialog.destroy()

            self.cleanup_lock_file()
            Gtk.main_quit()

        except Exception as e:
            log_with_timestamp(
                f"Error ignoring notifications: {e}", "ERROR", self.config_dir
            )

    def on_close_clicked(self, button):
        """Handle close button click"""
        self.user_interacted = True  # Mark that user interacted
        log_with_timestamp("User clicked Close button", "DIALOG", self.config_dir)

        # Cancel timeout since user interacted
        if self.dialog_timeout_id:
            GLib.source_remove(self.dialog_timeout_id)
            self.dialog_timeout_id = None
        self.cleanup_lock_file()
        Gtk.main_quit()

    def on_window_destroy(self, widget):
        """Handle window destruction"""
        # Cancel timeout if still active
        if self.dialog_timeout_id:
            GLib.source_remove(self.dialog_timeout_id)
            self.dialog_timeout_id = None

        # Log dialog destruction
        log_with_timestamp(
            f"Dialog destroyed (user_interacted: {self.user_interacted})",
            "DIALOG",
            self.config_dir,
        )

        # Only mark as interacted if dialog was visible for reasonable time
        # This prevents marking as interacted when dialog fails to show
        self.cleanup_lock_file()
        Gtk.main_quit()

    def on_dialog_timeout(self):
        """Handle dialog timeout - send fallback notification if no user interaction"""
        if not self.user_interacted:
            log_with_timestamp(
                "Dialog timeout - no user interaction detected",
                "DIALOG",
                self.config_dir,
            )
            print(
                "Dialog timeout - user may not have seen GTK dialog, sending fallback notification"
            )
            # Send system notification as fallback
            try:
                subprocess.run(
                    [
                        "notify-send",
                        "--urgency=critical",
                        "--icon=system-software-update",
                        "ArchRiot Update Available",
                        f"New version {self.remote_version} is available!\nCurrent: {self.local_version}\n\nRun: python3 bin/version-check --force\nLogs: ~/.cache/archriot/runtime.log\n(Non-blocking: you can continue working.)",
                    ],
                    check=False,
                )
                print("Fallback notification sent")
            except Exception as e:
                log_with_timestamp(
                    f"Failed to send fallback notification: {e}",
                    "WARNING",
                    self.config_dir,
                )

            # Close the invisible dialog
            self.cleanup_lock_file()
            Gtk.main_quit()

        # Remove timeout
        self.dialog_timeout_id = None
        return False  # Don't repeat timeout

    def load_config(self):
        """Load version check configuration"""
        return load_config(self.config_file)

    def save_config(self, config):
        """Save version check configuration"""
        save_config(self.config_file, self.config_dir, config)

    def setup_styling(self):
        """Set up CSS styling from external file or embedded default"""
        css_provider = Gtk.CssProvider()
        css_data = load_css_styling(self.config_dir)
        css_provider.load_from_data(css_data.encode())

        # Apply CSS to default screen
        screen = Gdk.Screen.get_default()
        Gtk.StyleContext.add_provider_for_screen(
            screen, css_provider, Gtk.STYLE_PROVIDER_PRIORITY_USER
        )


class VersionChecker:
    """Manages version checking, comparison, and notification logic for ArchRiot updates."""

    def __init__(self):
        self.home_dir = os.path.expanduser("~")
        self.config_dir = os.path.join(self.home_dir, ".config", "archriot")
        self.config_file = os.path.join(self.config_dir, "versions.cfg")
        self.version_file = os.path.join(
            self.home_dir, ".local", "share", "archriot", "VERSION"
        )

    def load_config(self):
        """Load version check configuration"""
        return load_config(self.config_file)

    def save_config(self, config):
        """Save version check configuration"""
        save_config(self.config_file, self.config_dir, config)

    def get_local_version(self):
        """Read local ArchRiot version from VERSION file"""
        try:
            with open(self.version_file, "r") as f:
                version = f.read().strip()
                return version
        except Exception as e:
            log_with_timestamp(f"Error reading local version: {e}", "ERROR")
            return None

    def get_remote_version(self):
        """Fetch remote version from GitHub API"""
        try:
            # Primary method: Direct VERSION file from ArchRiot website
            url = "https://raw.githubusercontent.com/CyphrRiot/ArchRiot/master/VERSION"
            req = urllib.request.Request(url)
            req.add_header("User-Agent", "ArchRiot-VersionChecker/1.0")

            with urllib.request.urlopen(req, timeout=10) as response:
                version = response.read().decode().strip()
                return version

        except Exception as e:
            print(f"Primary version fetch failed: {e}")

        try:
            # Fallback method: GitHub API
            url = "https://api.github.com/repos/CyphrRiot/ArchRiot/releases/latest"
            req = urllib.request.Request(url)
            req.add_header("User-Agent", "ArchRiot-VersionChecker/1.0")

            with urllib.request.urlopen(req, timeout=10) as response:
                data = json.loads(response.read().decode())
                tag_name = data.get("tag_name", "")
                # Remove 'v' prefix if present
                version = tag_name.lstrip("v")
                return version

        except Exception as e:
            log_with_timestamp(f"Fallback GitHub API failed: {e}", "WARNING")
            return None

    def parse_version(self, version_str):
        """Parse version string into comparable tuple"""
        if not version_str:
            return (0, 0, 0)

        # Handle common version prefixes (v1.2.3, version-1.2.3, etc.)
        version_str = version_str.strip()
        if version_str.lower().startswith("v"):
            version_str = version_str[1:]
        elif version_str.lower().startswith("version"):
            version_str = version_str[7:].lstrip("-_")

        # Extract the numeric part before any non-numeric suffix (e.g., "1.2.3-beta" -> "1.2.3")
        version_match = re.match(r"^(\d+(?:\.\d+)*)", version_str)
        if not version_match:
            print(
                f"Warning: Could not parse version string '{version_str}', using (0, 0, 0)"
            )
            return (0, 0, 0)

        clean_version = version_match.group(1)
        parts = clean_version.split(".")

        try:
            # Convert to integers, filtering out any empty parts
            int_parts = []
            for part in parts:
                if part:  # Skip empty parts from consecutive dots
                    int_parts.append(int(part))

            # Pad with zeros if needed and take first 3 parts
            while len(int_parts) < 3:
                int_parts.append(0)
            return tuple(int_parts[:3])
        except ValueError as e:
            print(
                f"Warning: Error parsing version '{version_str}': {e}, using (0, 0, 0)"
            )
            return (0, 0, 0)

    def is_newer_version(self, local_version, remote_version):
        """Compare versions semantically"""
        local_tuple = self.parse_version(local_version)
        remote_tuple = self.parse_version(remote_version)

        return remote_tuple > local_tuple

    def should_check_now(self, config):
        """Determine if we should check for updates now"""
        if config.get("ignore_notifications", False):
            return False

        last_check = config.get("last_check")
        if not last_check:
            return True

        try:
            last_check_time = datetime.fromisoformat(last_check.replace("Z", "+00:00"))
            now = datetime.now(timezone.utc)
            hours_since_check = (now - last_check_time).total_seconds() / 3600

            interval = config.get("check_interval_hours", 4)
            return hours_since_check >= interval
        except Exception:
            return True

    def should_notify_version(self, config, remote_version):
        """Check if we should notify about this specific version"""
        last_notified = config.get("last_notified_version")
        if not last_notified:
            return True

        # Don't notify again for the same version
        return last_notified != remote_version

    def get_commits_between_versions(self, local_version, remote_version):
        """Fetch commit messages between two versions using GitHub API"""
        try:
            # First try with version tags
            url = f"https://api.github.com/repos/CyphrRiot/ArchRiot/compare/v{local_version}...v{remote_version}"
            req = urllib.request.Request(url)
            req.add_header("User-Agent", "ArchRiot-VersionChecker/1.0")
            req.add_header("Accept", "application/vnd.github.v3+json")

            with urllib.request.urlopen(req, timeout=10) as response:
                data = json.loads(response.read().decode())

                commits = data.get("commits", [])
                commit_messages = []

                for commit in commits:
                    message = commit.get("commit", {}).get("message", "").strip()
                    if message:
                        # Take first 2-3 lines of commit message for more detail
                        lines = message.split("\n")
                        # Get title and first few non-empty lines
                        display_lines = []
                        for line in lines[:4]:  # Max 4 lines to check
                            clean_line = line.strip()
                            if (
                                clean_line and len(display_lines) < 3
                            ):  # Max 3 lines to show
                                display_lines.append(clean_line)

                        if display_lines and not display_lines[0].startswith(
                            "Merge"
                        ):  # Skip merge commits
                            # Join lines with newlines to preserve formatting
                            formatted_message = "\n".join(display_lines)
                            commit_messages.append(formatted_message)

                return commit_messages[:10]  # Limit to 10 most recent commits

        except urllib.error.HTTPError as e:
            if e.code == 404:
                log_with_timestamp(
                    f"Version tags not found for comparison (local: v{local_version}, remote: v{remote_version}) - commits unavailable",
                    "WARNING",
                )
            else:
                log_with_timestamp(
                    f"HTTP error fetching commits ({e.code}): {e}", "WARNING"
                )
            return []
        except Exception as e:
            log_with_timestamp(f"Error fetching version commits: {e}", "WARNING")
            return []

    def launch_update_dialog(self, local_version, remote_version):
        """Launch the update notification dialog directly"""
        # Check if update dialog is already running using lock file
        lock_file = "/tmp/archriot_upgrade.lock"
        if os.path.exists(lock_file):
            try:
                with open(lock_file, "r") as f:
                    lock_pid = f.read().strip()
                # Check if the PID is still running
                if os.path.exists(f"/proc/{lock_pid}"):
                    print("Update dialog already running - skipping duplicate")
                    return False
                else:
                    # Stale lock file, remove it
                    os.remove(lock_file)
            except Exception as e:
                print(f"Warning: Could not check lock file: {e}")

        try:
            print(
                f"Launching direct GTK dialog with LOCAL={local_version}, REMOTE={remote_version}"
            )

            # Fetch commit messages for dynamic content
            commit_messages = self.get_commits_between_versions(
                local_version, remote_version
            )
            print(f"Fetched {len(commit_messages)} commit messages")
            if commit_messages:
                print("Commit messages to display:")
                for i, msg in enumerate(commit_messages[:8], 1):
                    print(f"  {i}. {msg}")

            # Create and show dialog directly - no subprocess needed!
            dialog = UpdateDialog(
                local_version, remote_version, commit_messages, disable_timeout=True
            )

            # Run GTK main loop
            Gtk.main()

            print("Dialog closed by user")

            # Only return True if user actually interacted with the dialog
            # This prevents marking versions as "notified" when dialog isn't visible
            if dialog.user_interacted:
                print("User interacted with dialog - marking as notified")
                return True
            else:
                print("User did not interact with dialog - will retry on next check")
                return False

        except Exception as e:
            log_with_timestamp(f"Error launching update dialog: {e}", "ERROR")
            return False

    def update_check_timestamp(self, config):
        """Update the last check timestamp"""
        config["last_check"] = datetime.now(timezone.utc).isoformat()
        save_config(self.config_file, self.config_dir, config)

    def update_notified_version(self, config, version):
        """Update the last notified version"""
        config["last_notified_version"] = version
        save_config(self.config_file, self.config_dir, config)

    def is_running_from_systemd(self):
        """Check if we're running from systemd using multiple indicators"""
        # Check for systemd-specific environment variables
        if os.environ.get("INVOCATION_ID"):  # Set by systemd for all services
            return True

        # Check if parent process is systemd
        try:
            ppid = os.getppid()
            with open(f"/proc/{ppid}/comm", "r") as f:
                parent_name = f.read().strip()
            if parent_name == "systemd":
                return True
        except:
            pass

        # Fallback to original method as last resort
        return not os.environ.get("TERM") and not sys.stdin.isatty()

    def run_check(self, force=False):
        """Main version check logic"""
        config = load_config(self.config_file)

        # Check if we should run now (unless forced)
        if not force and not self.should_check_now(config):
            return

        # Update check timestamp
        self.update_check_timestamp(config)

        # Get local version
        local_version = self.get_local_version()
        if not local_version:
            print("Could not determine local version")
            return

        # Get remote version
        remote_version = self.get_remote_version()
        if not remote_version:
            print("Could not fetch remote version")
            return

        print(f"Local version: {local_version}")
        print(f"Remote version: {remote_version}")

        # Check if update is available
        if self.is_newer_version(local_version, remote_version):
            print("Update available!")

            # Check if we should notify about this version
            if self.should_notify_version(config, remote_version):
                # Check if running from systemd using robust detection
                is_systemd = self.is_running_from_systemd()

                if is_systemd:
                    print("Running from systemd - creating waybar notification flag")
                    # Create flag file for waybar to show update icon
                    update_flag_file = os.path.join(self.config_dir, "update_available")
                    try:
                        with open(update_flag_file, "w") as f:
                            f.write(
                                f"UPDATE_AVAILABLE:{local_version}->{remote_version}\n"
                            )
                        print(
                            f"Update flag created: {local_version} -> {remote_version}"
                        )
                        # Don't mark as notified - let user click the waybar icon
                    except Exception as e:
                        log_with_timestamp(
                            f"Failed to create update flag: {e}", "ERROR"
                        )
                else:
                    print("Running interactively - launching GUI notification...")
                    success = self.launch_update_dialog(local_version, remote_version)

                    # Only mark as notified if GUI notification was successful AND user interacted
                    if success:
                        self.update_notified_version(config, remote_version)
                        print("Update notification completed successfully")
                    else:
                        print(
                            "GUI notification failed or user did not interact - will retry on next check"
                        )
            else:
                print("Already notified about this version")
        else:
            print("No update available")


def main():
    """Main entry point"""
    checker = VersionChecker()

    # Handle command line arguments
    if len(sys.argv) > 1:
        if sys.argv[1] == "--force":
            # Force check regardless of timing - always show GUI
            checker.run_check(force=True)
        elif sys.argv[1] == "--test":
            # Test mode - show current versions
            local = checker.get_local_version()
            remote = checker.get_remote_version()
            print(f"Local: {local}")
            print(f"Remote: {remote}")
            if local and remote:
                is_newer = checker.is_newer_version(local, remote)
                print(f"Update available: {is_newer}")
        elif sys.argv[1] == "--reset":
            # Reset entire config to defaults
            config = {
                "ignore_notifications": False,
                "last_check": None,
                "last_notified_version": None,
                "check_interval_hours": 4,
            }
            save_config(checker.config_file, checker.config_dir, config)
            print("Configuration reset")
        elif sys.argv[1] == "--reset-notifications":
            # Reset only notification state, keep other settings
            config = load_config(checker.config_file)
            config["last_notified_version"] = None
            save_config(checker.config_file, checker.config_dir, config)
            print("Notification state reset - will notify about current updates")
        elif sys.argv[1] == "--clear-flag":
            # Clear waybar update flag
            update_flag_file = os.path.join(checker.config_dir, "update_available")
            try:
                if os.path.exists(update_flag_file):
                    os.remove(update_flag_file)
                    print("Update flag cleared")
                else:
                    print("No update flag to clear")
            except Exception as e:
                log_with_timestamp(f"Failed to clear update flag: {e}", "ERROR")
        elif sys.argv[1] == "--gui":
            # Dynamic GUI launch - always read live VERSION file and git latest
            try:
                # Get current versions dynamically
                local_version = checker.get_local_version()
                remote_version = checker.get_remote_version()

                if not local_version:
                    print("Could not determine local version")
                    sys.exit(1)

                if not remote_version:
                    print("Could not fetch remote version")
                    sys.exit(1)

                # Check if update is available
                if checker.is_newer_version(local_version, remote_version):
                    print(f"Dynamic GUI launch: {local_version} -> {remote_version}")

                    # Fetch commit messages for dynamic content
                    commit_messages = checker.get_commits_between_versions(
                        local_version, remote_version
                    )
                    print(
                        f"Fetched {len(commit_messages)} commit messages for dynamic waybar dialog"
                    )

                    # Launch dialog with live data
                    dialog = UpdateDialog(
                        local_version,
                        remote_version,
                        commit_messages,
                        disable_timeout=True,
                    )
                    dialog.waybar_managed = True  # Flag to prevent auto-notification
                    Gtk.main()
                else:
                    print(
                        f"No update available - local {local_version} is up to date with remote {remote_version}"
                    )

            except Exception as e:
                log_with_timestamp(f"Error in dynamic GUI mode: {e}", "ERROR")
                log_with_timestamp(f"Error launching GUI: {e}", "ERROR")
        else:
            print(
                "Usage: version-check [--force|--test|--reset|--reset-notifications|--clear-flag|--gui]"
            )
            sys.exit(1)
    else:
        # Normal check
        checker.run_check()


if __name__ == "__main__":
    main()
