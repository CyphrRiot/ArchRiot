#!/usr/bin/env python3
"""
ArchRiot Control Panel
Centralized settings interface for ArchRiot components
"""

import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Gdk', '4.0')
gi.require_version('GdkPixbuf', '2.0')
from gi.repository import Gtk, Gdk, GLib, Pango, GdkPixbuf
import os
import sys
import time
from pathlib import Path

class ArchRiotDialog:
    """Reusable ArchRiot-themed dialog with proper background"""

    def __init__(self, title, content, parent_window=None):
        self.dialog = Gtk.Window()
        self.dialog.set_title(title)
        self.dialog.set_default_size(700, 600)
        self.dialog.set_resizable(True)
        self.dialog.set_modal(True)
        self.dialog.add_css_class("archriot-control-panel")

        if parent_window:
            self.dialog.set_transient_for(parent_window)

        self.create_layout(title, content)

    def create_layout(self, title, content):
        """Create the dialog layout using proven main window approach"""
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=20)
        main_box.set_margin_start(30)
        main_box.set_margin_end(30)
        main_box.set_margin_top(15)
        main_box.set_margin_bottom(20)

        # Title
        title_label = Gtk.Label()
        title_label.set_markup(f'<span size="28000" weight="bold" foreground="#bb9af7" font_family="Hack Nerd Font Mono">{title}</span>')
        title_label.set_halign(Gtk.Align.CENTER)
        main_box.append(title_label)

        # Content frame - same as main window
        content_frame = Gtk.Frame()
        content_frame.set_margin_top(10)
        content_frame.add_css_class("archriot-control-panel")

        content_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=15)
        content_box.set_margin_start(20)
        content_box.set_margin_end(20)
        content_box.set_margin_top(20)
        content_box.set_margin_bottom(20)

        # Content text
        content_label = Gtk.Label()
        content_label.set_markup(f'<span size="12000" font_family="Hack Nerd Font Mono">{content}</span>')
        content_label.set_wrap(True)
        content_label.set_halign(Gtk.Align.START)
        content_box.append(content_label)

        content_frame.set_child(content_box)
        main_box.append(content_frame)

        # Close button
        close_button = Gtk.Button(label="Close")
        close_button.set_halign(Gtk.Align.CENTER)
        close_button.connect("clicked", lambda x: self.dialog.close())
        # Apply Hack Nerd Font to button
        close_button.get_child().set_markup('<span font_family="Hack Nerd Font Mono">Close</span>')
        main_box.append(close_button)

        self.dialog.set_child(main_box)

    def show(self):
        """Show the dialog"""
        self.dialog.present()

# Import our configuration manager
def import_config_module():
    """Import the ArchRiot configuration system"""
    # Get script directory, handle both __file__ and execution contexts
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
    except NameError:
        # Fallback when __file__ is not defined (like in exec context)
        script_dir = os.getcwd()

    # Try from same directory first (development)
    config_script = os.path.join(script_dir, 'archriot-config')

    if os.path.exists(config_script):
        # Execute the config script to get the ArchRiotConfig class
        global_vars = {}
        with open(config_script, 'r') as f:
            exec(f.read(), global_vars)
        return global_vars['ArchRiotConfig']
    else:
        # Try from installed location
        home_bin = str(Path.home() / '.local' / 'bin' / 'archriot-config')
        if os.path.exists(home_bin):
            global_vars = {}
            with open(home_bin, 'r') as f:
                exec(f.read(), global_vars)
            return global_vars['ArchRiotConfig']
        else:
            # Create a minimal fallback config class
            class FallbackConfig:
                def __init__(self):
                    pass
                def get_pomodoro_config(self):
                    return {'enabled': True, 'duration': 25}
                def get_bluelight_config(self):
                    return {'enabled': True, 'temperature': 3500}
                def get_mullvad_config(self):
                    return {'enabled': False, 'account_number': '', 'auto_connect': False}
                def get_display_config(self):
                    return {'enabled': True, 'resolution': 1920, 'scaling': 100}
                def get_power_config(self):
                    return {'enabled': True, 'profile': 'balanced'}
                def set_pomodoro_config(self, enabled, duration):
                    pass
                def set_bluelight_config(self, enabled, temperature):
                    pass
                def set_mullvad_config(self, enabled, account_number='', auto_connect=False):
                    pass
                def set_display_config(self, enabled, resolution, scaling):
                    pass
                def set_power_config(self, enabled, profile):
                    pass
                def backup_config(self, name=None):
                    return "/tmp/fallback-backup"
            return FallbackConfig

ArchRiotConfig = import_config_module()

class BaseControlWidget:
    """Base class for control widgets with toggle and value control"""

    def __init__(self, config, title, description, icon):
        self.config = config
        self.title = title
        self.description = description
        self.icon = icon
        self.timeout_id = None

        # Create main container
        self.widget = self.create_section_frame()

    def create_section_frame(self):
        """Create the main frame for this widget"""
        frame = Gtk.Frame()
        frame.set_margin_bottom(3)

        # Create main container
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        main_box.set_margin_start(10)
        main_box.set_margin_end(10)
        main_box.set_margin_top(8)
        main_box.set_margin_bottom(8)

        # Title row with toggle
        self.title_row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)

        # Title
        title_label = Gtk.Label()
        title_label.set_markup(f'<span size="16000" weight="bold" foreground="#bb9af7">{self.icon} {self.title}</span>')
        title_label.set_halign(Gtk.Align.START)
        title_label.set_hexpand(True)
        self.title_row.append(title_label)

        main_box.append(self.title_row)

        # Controls container
        self.controls_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        main_box.append(self.controls_box)

        frame.set_child(main_box)
        return frame

    def create_toggle(self, label_text, initial_state, callback):
        """Create a toggle switch"""
        row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        label = Gtk.Label(label=label_text)
        label.set_halign(Gtk.Align.START)
        label.set_hexpand(True)

        switch = Gtk.Switch()
        switch.set_active(initial_state)
        switch.connect("notify::active", callback)

        row.append(label)
        row.append(switch)
        return row, switch

    def create_slider(self, label_text, min_val, max_val, step, current_val, enabled, marks, callback):
        """Create a slider with label"""
        row = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        label = Gtk.Label(label=label_text)
        label.set_halign(Gtk.Align.START)

        scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, min_val, max_val, step)
        scale.set_value(current_val)
        scale.set_draw_value(False)
        scale.set_sensitive(enabled)
        scale.connect("value-changed", callback)

        # Add tick marks
        for mark_val, mark_label in marks:
            scale.add_mark(mark_val, Gtk.PositionType.BOTTOM, mark_label)

        row.append(label)
        row.append(scale)
        return row, label, scale

    def debounced_save(self, save_function, delay_ms=500):
        """Debounce save operations"""
        if self.timeout_id:
            GLib.source_remove(self.timeout_id)
        self.timeout_id = GLib.timeout_add(delay_ms, save_function)

class PomodoroWidget(BaseControlWidget):
    """Pomodoro timer control widget"""

    def __init__(self, config, window=None):
        super().__init__(config, "Pomodoro Timer", "Control the built-in Waybar Pomodoro timer", "üçÖ")
        self.window = window
        self.setup_controls()

    def setup_controls(self):
        """Setup Pomodoro-specific controls"""
        pomodoro_config = self.config.get_pomodoro_config()

        # Duration label (add to title row)
        self.duration_label = Gtk.Label()
        self.duration_label.set_markup(f'<span size="11000" alpha="75%">Duration: {pomodoro_config["duration"]} minutes</span>')
        self.duration_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.duration_label)

        # Learn More link (add to title row)
        learn_link = Gtk.Button(label="Learn More")
        learn_link.connect("clicked", self.on_learn_more_clicked)
        learn_link.set_halign(Gtk.Align.END)
        self.title_row.append(learn_link)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(pomodoro_config['enabled'])
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Duration slider (just the slider, no label)
        duration_marks = [(i, f"{i}m") for i in range(5, 65, 5)]
        slider_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        self.duration_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 5, 60, 1)
        self.duration_scale.set_value(pomodoro_config['duration'])
        self.duration_scale.set_draw_value(False)
        self.duration_scale.set_sensitive(pomodoro_config['enabled'])
        self.duration_scale.connect("value-changed", self.on_duration_changed)

        # Add tick marks
        for mark_val, mark_label in duration_marks:
            self.duration_scale.add_mark(mark_val, Gtk.PositionType.BOTTOM, mark_label)

        slider_box.append(self.duration_scale)
        self.controls_box.append(slider_box)

    def on_toggle(self, switch, param):
        """Handle toggle switch"""
        state = switch.get_active()
        duration = int(self.duration_scale.get_value())

        # Update slider sensitivity
        self.duration_scale.set_sensitive(state)

        # Apply toggle change immediately to waybar
        self.apply_toggle_change(state, duration)

        # Mark changes pending
        self.mark_changes_pending()

    def on_duration_changed(self, scale):
        """Handle duration change with snapping"""
        value = scale.get_value()
        # Snap to nearest 5-minute increment (5, 10, 15, 20, 25, etc.)
        snapped_value = round(value / 5) * 5

        if abs(value - snapped_value) > 0.5:
            scale.set_value(snapped_value)
            return

        duration = int(snapped_value)
        self.duration_label.set_markup(f'<span size="11000" alpha="75%">Duration: {duration} minutes</span>')

        # Apply duration change immediately to waybar
        self.apply_duration_change(duration)

        # Mark changes pending
        self.mark_changes_pending()

    def apply_toggle_change(self, enabled, duration):
        """Apply toggle change immediately to waybar"""
        try:
            import subprocess
            # Save config immediately so waybar script can read it
            self.config.set_pomodoro_config(enabled, duration)
            # Refresh waybar pomodoro module
            subprocess.run(['pkill', '-RTMIN+8', 'waybar'], check=False)
        except Exception as e:
            print(f"Pomodoro waybar update error: {e}")

    def apply_duration_change(self, duration):
        """Apply duration change immediately to waybar"""
        try:
            import subprocess
            enabled = self.switch.get_active()
            # Save config immediately so waybar script can read it
            self.config.set_pomodoro_config(enabled, duration)
            # Refresh waybar pomodoro module
            subprocess.run(['pkill', '-RTMIN+8', 'waybar'], check=False)
        except Exception as e:
            print(f"Pomodoro waybar update error: {e}")

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        enabled = self.switch.get_active()
        duration = int(self.duration_scale.get_value())

        # Save to config (system changes already applied in real-time)
        self.config.set_pomodoro_config(enabled, duration)

    def on_learn_more_clicked(self, button):
        """Handle Learn More button click"""
        content = """The Pomodoro Technique is a time management method developed by Francesco Cirillo in the late 1980s. It uses a timer to break work into intervals, traditionally 25 minutes in length, separated by short breaks.

<b>How it works:</b>

1. Choose a task to work on
2. Set the timer for 25 minutes (or your preferred duration)
3. Work on the task until the timer rings
4. Take a short 5-minute break
5. After 4 pomodoros, take a longer 15-30 minute break

<b>Benefits:</b>

‚Ä¢ Improves focus and concentration
‚Ä¢ Reduces mental fatigue
‚Ä¢ Increases productivity
‚Ä¢ Helps overcome procrastination
‚Ä¢ Makes time tracking easier
‚Ä¢ Reduces burnout

The technique is named after the tomato-shaped kitchen timer that Cirillo used as a university student.

ArchRiot's built-in Pomodoro timer integrates directly with your Waybar, making it easy to stay focused while working in your Hyprland environment."""

        dialog = ArchRiotDialog(
            "üçÖ Pomodoro Technique",
            content,
            self.window.window if self.window else None
        )
        dialog.show()
class BlueLightWidget(BaseControlWidget):
    """Blue light filter control widget"""

    def __init__(self, config, window=None):
        super().__init__(config, "Blue Light Filter", "Control the built-in hyprsunset blue light filter", "üí°")
        self.window = window
        self.setup_controls()

    def setup_controls(self):
        """Setup blue light filter controls"""
        bluelight_config = self.config.get_bluelight_config()

        # Temperature label (add to title row)
        self.temp_label = Gtk.Label()
        self.temp_label.set_markup(f'<span size="11000" alpha="75%">Temperature: {bluelight_config["temperature"]}K</span>')
        self.temp_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.temp_label)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(bluelight_config['enabled'])
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Temperature slider (just the slider, no label)
        temp_marks = [(i, f"{i}K") for i in range(2500, 5500, 500)]
        slider_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        self.temp_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 2500, 5000, 100)
        self.temp_scale.set_value(bluelight_config['temperature'])
        self.temp_scale.set_draw_value(False)
        self.temp_scale.set_sensitive(bluelight_config['enabled'])
        self.temp_scale.connect("value-changed", self.on_temperature_changed)

        # Add tick marks
        for mark_val, mark_label in temp_marks:
            self.temp_scale.add_mark(mark_val, Gtk.PositionType.BOTTOM, mark_label)

        slider_box.append(self.temp_scale)
        self.controls_box.append(slider_box)

    def on_toggle(self, switch, param):
        """Handle toggle switch"""
        state = switch.get_active()
        temperature = int(self.temp_scale.get_value())

        # Update slider sensitivity
        self.temp_scale.set_sensitive(state)

        # Apply change immediately
        if state:
            self.apply_temperature_change(temperature)
        else:
            self.disable_blue_light_filter()

        # Mark changes pending
        self.mark_changes_pending()

    def on_temperature_changed(self, scale):
        """Handle temperature change with snapping"""
        value = scale.get_value()
        # Snap to nearest 500K increment
        snapped_value = round(value / 500) * 500

        if abs(value - snapped_value) > 50:
            scale.set_value(snapped_value)
            return

        temperature = int(snapped_value)
        self.temp_label.set_markup(f'<span size="11000" alpha="75%">Temperature: {temperature}K</span>')

        # Apply temperature change immediately
        if self.switch.get_active():
            self.apply_temperature_change(temperature)

        # Mark changes pending
        self.mark_changes_pending()

    def apply_temperature_change(self, temperature):
        """Apply temperature change immediately to system and update config"""
        try:
            import subprocess
            import re
            from pathlib import Path

            # Kill any existing hyprsunset processes (ensure only one instance)
            subprocess.run(['pkill', '-f', 'hyprsunset'], check=False)
            # Wait a moment for processes to fully terminate
            time.sleep(0.1)
            # Start hyprsunset with new temperature as detached process
            subprocess.Popen(['hyprsunset', '-t', str(temperature)],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                           preexec_fn=os.setsid)

            # Update Hyprland config to make change persistent
            hyprland_config = Path.home() / '.config' / 'hypr' / 'hyprland.conf'
            if hyprland_config.exists():
                content = hyprland_config.read_text()
                # Replace hyprsunset line with new temperature
                content = re.sub(r'exec-once = hyprsunset -t \d+',
                               f'exec-once = hyprsunset -t {temperature}', content)
                hyprland_config.write_text(content)
        except Exception as e:
            print(f"Blue light filter error: {e}")  # Debug output

    def disable_blue_light_filter(self):
        """Disable blue light filter immediately and update config"""
        try:
            import subprocess
            import re
            from pathlib import Path

            # Kill any existing hyprsunset processes (ensure complete shutdown)
            subprocess.run(['pkill', '-f', 'hyprsunset'], check=False)
            # Wait a moment for processes to fully terminate
            time.sleep(0.1)

            # Comment out hyprsunset line in Hyprland config
            hyprland_config = Path.home() / '.config' / 'hypr' / 'hyprland.conf'
            if hyprland_config.exists():
                content = hyprland_config.read_text()
                # Comment out the hyprsunset line
                content = re.sub(r'exec-once = hyprsunset -t \d+',
                               '# exec-once = hyprsunset -t 3500  # Disabled via Control Panel', content)
                hyprland_config.write_text(content)
        except Exception as e:
            print(f"Blue light filter disable error: {e}")  # Debug output

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        enabled = self.switch.get_active()
        temperature = int(self.temp_scale.get_value())

        # Save to config (system changes already applied in real-time)
        self.config.set_bluelight_config(enabled, temperature)

class MullvadWidget(BaseControlWidget):
    """Mullvad VPN control widget"""

    def __init__(self, config, window=None):
        super().__init__(config, "Mullvad VPN", "Manage VPN connection and account settings", "üõ°Ô∏è")
        self.window = window
        self.setup_controls()

    def setup_controls(self):
        """Setup Mullvad VPN controls"""
        mullvad_config = self.config.get_mullvad_config()

        # Get current account and auto-connect status from Mullvad
        current_account = self.get_current_mullvad_account()
        current_auto_connect = self.get_current_auto_connect_status()

        if current_account and not mullvad_config['account_number']:
            mullvad_config['account_number'] = current_account

        # Use actual system auto-connect status, not config
        actual_auto_connect = current_auto_connect if current_auto_connect is not None else mullvad_config['auto_connect']

        # Auto-connect label (add to title row)
        self.auto_connect_label = Gtk.Label()
        self.auto_connect_label.set_markup(f'<span size="11000" alpha="75%">Auto-connect: {"On" if actual_auto_connect else "Off"}</span>')
        self.auto_connect_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.auto_connect_label)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(actual_auto_connect)
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Account number entry
        account_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        account_label = Gtk.Label(label="Account Number:")
        account_label.set_halign(Gtk.Align.START)

        self.account_entry = Gtk.Entry()
        self.account_entry.set_placeholder_text("1234 5678 9012 3456")

        # Show account number privately (hidden by default)
        account_number = mullvad_config['account_number'] or current_account or ""
        if account_number:
            self.account_entry.set_visibility(False)  # Hide by default
            self.account_entry.set_text(self.format_account_number(account_number))
            self.is_account_visible = False
        else:
            self.account_entry.set_text("")
            self.is_account_visible = True

        self.account_entry.set_max_length(19)
        self.account_entry.set_width_chars(25)
        self.account_entry.connect("changed", self.on_account_changed)
        self.account_entry.connect("activate", self.on_account_activate)

        account_box.append(account_label)
        account_box.append(self.account_entry)

        # Eye toggle button for show/hide
        self.eye_button = Gtk.Button()
        self.eye_button.set_size_request(40, -1)  # Set minimum width
        self.eye_button.set_halign(Gtk.Align.CENTER)
        self.update_eye_button()
        self.eye_button.connect("clicked", self.on_eye_toggle)
        account_box.append(self.eye_button)

        # Spacer to push button right
        spacer = Gtk.Box()
        spacer.set_hexpand(True)
        account_box.append(spacer)

        # Get Mullvad VPN button (same line, right-justified)
        link_button = Gtk.Button(label="Get Mullvad VPN")
        link_button.connect("clicked", self.on_get_mullvad_clicked)
        link_button.set_halign(Gtk.Align.END)
        account_box.append(link_button)

        self.controls_box.append(account_box)

    def on_toggle(self, switch, param):
        """Handle auto-connect toggle switch"""
        state = switch.get_active()
        account_number = self.account_entry.get_text()

        # Update label
        self.auto_connect_label.set_markup(f'<span size="11000" alpha="75%">Auto-connect: {"On" if state else "Off"}</span>')

        # Apply changes immediately to system
        self.apply_toggle_change(state, account_number)

        # Mark changes pending
        self.mark_changes_pending()

    def format_account_number(self, account_number):
        """Format account number with spaces every 4 digits"""
        # Remove any existing spaces
        clean = account_number.replace(' ', '')
        # Add spaces every 4 digits
        formatted = ' '.join(clean[i:i+4] for i in range(0, len(clean), 4))
        return formatted

    def on_account_changed(self, entry):
        """Handle account number input with auto-formatting"""
        text = entry.get_text()
        cursor_pos = entry.get_position()

        # Only allow digits and spaces
        filtered = ''.join(c for c in text if c.isdigit() or c == ' ')

        # Remove all spaces and re-format
        digits_only = ''.join(c for c in filtered if c.isdigit())

        # Limit to 16 digits
        if len(digits_only) > 16:
            digits_only = digits_only[:16]

        # Format with spaces
        formatted = self.format_account_number(digits_only)

        # Update field if changed
        if formatted != text:
            # Calculate new cursor position accounting for added spaces
            digits_before_cursor = len(''.join(c for c in text[:cursor_pos] if c.isdigit()))
            spaces_before_cursor = (digits_before_cursor - 1) // 4 if digits_before_cursor > 0 else 0
            new_pos = digits_before_cursor + spaces_before_cursor

            entry.set_text(formatted)
            entry.set_position(min(new_pos, len(formatted)))

    def on_account_activate(self, entry):
        """Handle account number validation when user presses Enter"""
        text = entry.get_text()
        clean_text = text.replace(' ', '')

        # Apply account change immediately
        self.apply_account_change(clean_text)

        # Mark changes pending
        self.mark_changes_pending()

    def get_current_mullvad_account(self):
        """Get current Mullvad account number from system"""
        try:
            import subprocess
            result = subprocess.run(['mullvad', 'account', 'get'], capture_output=True, text=True)
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'Mullvad account:' in line:
                        account = line.split(':')[1].strip()
                        return account
        except Exception:
            pass
        return None

    def get_current_auto_connect_status(self):
        """Get current auto-connect status from Mullvad"""
        try:
            import subprocess
            result = subprocess.run(['mullvad', 'auto-connect', 'get'], capture_output=True, text=True)
            if result.returncode == 0:
                return 'on' in result.stdout.lower()
        except Exception:
            pass
        return None

    def update_eye_button(self):
        """Update eye button appearance based on visibility state"""
        if hasattr(self, 'is_account_visible') and self.is_account_visible:
            self.eye_button.set_label("üëÅÔ∏è")  # Open eye = visible
        else:
            self.eye_button.set_label("üîí")  # Lock = hidden

    def on_eye_toggle(self, button):
        """Toggle account number visibility"""
        self.is_account_visible = not self.is_account_visible
        self.account_entry.set_visibility(self.is_account_visible)
        self.update_eye_button()

    def apply_toggle_change(self, enabled, account_number):
        """Apply auto-connect toggle change immediately"""
        try:
            import subprocess
            from pathlib import Path

            # Set auto-connect
            if enabled:
                subprocess.run(['mullvad', 'auto-connect', 'set', 'on'], check=False)

                # Update Hyprland config to start Mullvad GUI
                hyprland_config = Path.home() / '.config' / 'hypr' / 'hyprland.conf'
                if hyprland_config.exists():
                    content = hyprland_config.read_text()
                    if 'exec-once = mullvad-vpn' not in content:
                        # Add Mullvad GUI to exec-once
                        content += '\nexec-once = mullvad-vpn\n'
                        hyprland_config.write_text(content)
            else:
                subprocess.run(['mullvad', 'auto-connect', 'set', 'off'], check=False)

                # Remove Mullvad GUI from Hyprland config
                hyprland_config = Path.home() / '.config' / 'hypr' / 'hyprland.conf'
                if hyprland_config.exists():
                    content = hyprland_config.read_text()
                    content = content.replace('exec-once = mullvad-vpn\n', '')
                    content = content.replace('\nexec-once = mullvad-vpn', '')
                    hyprland_config.write_text(content)
        except Exception as e:
            print(f"Mullvad toggle error: {e}")

    def apply_account_change(self, account_number):
        """Apply account login immediately"""
        try:
            import subprocess
            if account_number and len(account_number) >= 10:
                subprocess.run(['mullvad', 'account', 'login', account_number], check=False)
        except Exception as e:
            print(f"Mullvad account error: {e}")

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        auto_connect = self.switch.get_active()
        account_number = self.account_entry.get_text().replace(' ', '')

        # Save to config (system changes already applied in real-time)
        self.config.set_mullvad_config(auto_connect, account_number, auto_connect)

    def on_get_mullvad_clicked(self, button):
        """Open Mullvad VPN website"""
        import subprocess
        subprocess.Popen(['xdg-open', 'https://mullvad.net'])

class AudioWidget(BaseControlWidget):
    """Audio system control widget"""

    def __init__(self, config, window=None):
        super().__init__(config, "Audio", "PipeWire/PulseAudio configuration", "üîä")
        self.window = window
        self.setup_controls()

    def setup_controls(self):
        """Setup audio system controls"""
        # Get current audio system status
        current_status = self.get_audio_status()

        # Audio enabled label (add to title row)
        self.audio_label = Gtk.Label()
        self.audio_label.set_markup(f'<span size="11000" alpha="75%">Audio: {"On" if current_status else "Off"}</span>')
        self.audio_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.audio_label)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(current_status)
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

    def on_toggle(self, switch, param):
        """Handle audio system toggle switch"""
        state = switch.get_active()

        # Update label
        self.audio_label.set_markup(f'<span size="11000" alpha="75%">Audio: {"On" if state else "Off"}</span>')

        # Apply audio system change immediately
        self.apply_audio_change(state)

        # Mark changes pending
        self.mark_changes_pending()

    def get_audio_status(self):
        """Get current audio mute status"""
        try:
            import subprocess
            # Check if audio is muted using pactl
            result = subprocess.run(['pactl', 'get-sink-mute', '@DEFAULT_SINK@'],
                                  capture_output=True, text=True)
            if result.returncode == 0:
                return 'no' in result.stdout.lower()  # 'no' means not muted = audio on
            return True  # Default to on if we can't detect
        except Exception:
            return True  # Default to on if we can't detect

    def apply_audio_change(self, enabled):
        """Apply audio mute/unmute change immediately"""
        try:
            import subprocess
            if enabled:
                # Unmute audio
                subprocess.run(['pactl', 'set-sink-mute', '@DEFAULT_SINK@', '0'], check=False)
            else:
                # Mute audio
                subprocess.run(['pactl', 'set-sink-mute', '@DEFAULT_SINK@', '1'], check=False)
        except Exception as e:
            print(f"Audio mute error: {e}")

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        # Audio changes are already applied in real-time
        pass

class CameraWidget(BaseControlWidget):
    """Camera system control widget"""

    def __init__(self, config, window=None):
        super().__init__(config, "Camera", "Camera control and resolution settings", "üì∑")
        self.window = window
        self.setup_controls()

    def setup_controls(self):
        """Setup camera controls"""
        # Get current camera status and resolution
        current_status = self.get_camera_status()
        current_resolution = self.get_camera_resolution()

        # Resolution label (add to title row)
        self.resolution_label = Gtk.Label()
        self.resolution_label.set_markup(f'<span size="11000" alpha="75%">Resolution: {current_resolution}</span>')
        self.resolution_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.resolution_label)

        # Test Camera button (add to title row)
        test_button = Gtk.Button(label="Test Camera")
        test_button.connect("clicked", self.on_test_camera)
        test_button.set_sensitive(current_status)
        self.test_button = test_button
        self.title_row.append(test_button)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(current_status)
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Resolution slider
        self.available_resolutions = ["640x480", "960x540", "960x720", "1280x720", "1920x1080"]
        resolution_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        self.resolution_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 0, len(self.available_resolutions)-1, 1)

        # Set to current resolution
        current_index = 0
        for i, res in enumerate(self.available_resolutions):
            if res == current_resolution:
                current_index = i
                break

        self.resolution_scale.set_value(current_index)
        self.resolution_scale.set_draw_value(False)
        self.resolution_scale.set_sensitive(current_status)
        self.resolution_scale.connect("value-changed", self.on_resolution_changed)

        # Add margins to prevent text cutoff
        self.resolution_scale.set_margin_start(40)
        self.resolution_scale.set_margin_end(40)

        # Add tick marks
        for i, res in enumerate(self.available_resolutions):
            self.resolution_scale.add_mark(i, Gtk.PositionType.BOTTOM, res)

        resolution_box.append(self.resolution_scale)
        self.controls_box.append(resolution_box)

    def on_toggle(self, switch, param):
        """Handle camera toggle switch"""
        state = switch.get_active()

        # Update slider and test button sensitivity
        self.resolution_scale.set_sensitive(state)
        self.test_button.set_sensitive(state)

        # Apply camera change immediately
        self.apply_camera_change(state)

        # Mark changes pending
        self.mark_changes_pending()

    def on_resolution_changed(self, scale):
        """Handle resolution change with snapping"""
        value = scale.get_value()
        # Snap to nearest resolution index
        snapped_value = round(value)

        if abs(value - snapped_value) > 0.1:
            scale.set_value(snapped_value)
            return

        # Apply resolution change immediately
        index = int(snapped_value)
        if 0 <= index < len(self.available_resolutions):
            resolution = self.available_resolutions[index]
            self.resolution_label.set_markup(f'<span size="11000" alpha="75%">Resolution: {resolution}</span>')
            self.apply_resolution_change(resolution)

        # Mark changes pending
        self.mark_changes_pending()

    def on_test_camera(self, button):
        """Handle test camera button click"""
        self.show_camera_preview()

    def get_camera_status(self):
        """Get current camera device status"""
        try:
            import os
            # Check if camera devices exist and are accessible
            camera_devices = ['/dev/video0', '/dev/video1']
            for device in camera_devices:
                if os.path.exists(device) and os.access(device, os.R_OK):
                    return True
            return False
        except Exception:
            return False

    def get_camera_resolution(self):
        """Get current camera resolution"""
        try:
            import subprocess
            result = subprocess.run(['v4l2-ctl', '--get-fmt-video', '-d', '/dev/video0'], capture_output=True, text=True)
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'Width/Height' in line:
                        # Extract resolution from "Width/Height      : 960/720"
                        parts = line.split(':')[1].strip().split('/')
                        if len(parts) == 2:
                            width = parts[0].strip()
                            height = parts[1].strip()
                            return f"{width}x{height}"
            return "960x720"  # Default to current actual resolution
        except Exception:
            return "960x720"  # Default to current actual resolution

    def apply_camera_change(self, enabled):
        """Apply camera access change immediately"""
        try:
            import subprocess
            import os

            camera_devices = ['/dev/video0', '/dev/video1']

            if enabled:
                # Enable camera access by setting proper permissions
                for device in camera_devices:
                    if os.path.exists(device):
                        subprocess.run(['sudo', 'chmod', '666', device], check=False)
            else:
                # Disable camera access by removing permissions
                for device in camera_devices:
                    if os.path.exists(device):
                        subprocess.run(['sudo', 'chmod', '000', device], check=False)
        except Exception as e:
            print(f"Camera access error: {e}")

    def apply_resolution_change(self, resolution):
        """Apply camera resolution change immediately"""
        try:
            import subprocess
            width, height = resolution.split('x')
            # Set camera resolution using v4l2-ctl
            subprocess.run(['v4l2-ctl', '-d', '/dev/video0', '--set-fmt-video=width={},height={},pixelformat=MJPG'.format(width, height)], check=False)
        except Exception as e:
            print(f"Camera resolution error: {e}")

    def show_camera_preview(self):
        """Show simple GTK camera preview dialog"""
        try:
            import cv2
            import threading
            import time
            from gi.repository import GLib
            import numpy as np

            # Create camera preview dialog
            dialog = Gtk.Window()
            dialog.set_default_size(700, 600)
            dialog.set_modal(True)
            dialog.set_transient_for(self.window.window if self.window else None)
            dialog.add_css_class("archriot-control-panel")

            main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=20)
            main_box.set_margin_start(30)
            main_box.set_margin_end(30)
            main_box.set_margin_top(15)
            main_box.set_margin_bottom(20)

            # Header
            title_label = Gtk.Label()
            title_label.set_markup('<span size="28000" weight="bold" foreground="#bb9af7">üì∑ Camera Video Test</span>')
            title_label.set_halign(Gtk.Align.CENTER)
            main_box.append(title_label)

            # Content frame
            content_frame = Gtk.Frame()
            content_frame.set_margin_top(10)
            content_frame.add_css_class("archriot-control-panel")
            content_frame.set_vexpand(True)

            # Video display - fill the content frame completely
            self.camera_image = Gtk.Image()
            self.camera_image.set_hexpand(True)
            self.camera_image.set_vexpand(True)
            self.camera_image.set_halign(Gtk.Align.FILL)
            self.camera_image.set_valign(Gtk.Align.FILL)

            content_frame.set_child(self.camera_image)
            main_box.append(content_frame)

            # Close button
            close_button = Gtk.Button(label="Close")
            close_button.set_halign(Gtk.Align.CENTER)
            close_button.connect("clicked", lambda x: self.stop_camera_and_close(dialog))
            main_box.append(close_button)

            dialog.set_child(main_box)
            dialog.present()

            # Start camera feed
            self.camera_running = True
            self.camera_thread = threading.Thread(target=self.camera_feed_loop)
            self.camera_thread.daemon = True
            self.camera_thread.start()

        except ImportError:
            # Fallback if OpenCV not available
            content = "Camera preview requires OpenCV (python-opencv). Please install it:\n\nsudo pacman -S python-opencv"
            fallback_dialog = ArchRiotDialog("üì∑ Camera Preview", content, self.window.window if self.window else None)
            fallback_dialog.show()
        except Exception as e:
            print(f"Camera preview error: {e}")

    def stop_camera_and_close(self, dialog):
        """Stop camera and close dialog"""
        self.camera_running = False
        if hasattr(self, 'cap'):
            self.cap.release()
        dialog.close()

    def camera_feed_loop(self):
        """Camera feed loop running in background thread"""
        try:
            import cv2
            self.cap = cv2.VideoCapture(0)
            self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
            self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

            while self.camera_running:
                ret, frame = self.cap.read()
                if ret:
                    # Convert BGR to RGB
                    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

                    # Convert to GdkPixbuf
                    height, width, channels = frame_rgb.shape
                    pixbuf = GdkPixbuf.Pixbuf.new_from_data(
                        frame_rgb.tobytes(),
                        GdkPixbuf.Colorspace.RGB,
                        False,
                        8,
                        width,
                        height,
                        width * channels
                    )

                    # Update image on main thread
                    GLib.idle_add(self.update_camera_image, pixbuf)

                time.sleep(1/30)  # 30 FPS

            self.cap.release()
        except Exception as e:
            print(f"Camera feed error: {e}")

    def update_camera_image(self, pixbuf):
        """Update camera image on main thread"""
        if hasattr(self, 'camera_image'):
            self.camera_image.set_from_pixbuf(pixbuf)
        return False

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        # Camera changes are already applied in real-time
        pass

class DisplayWidget(BaseControlWidget):
    """Display settings control widget"""

    def __init__(self, config, window=None):
        super().__init__(config, "Display Settings", "Monitor configuration and scaling", "üñ•Ô∏è")
        self.window = window
        self.setup_controls()

    def get_available_resolutions(self):
        """Get available monitor resolutions from hyprctl"""
        print("üîç DEBUG: Getting available resolutions...")
        try:
            import subprocess
            result = subprocess.run(['hyprctl', 'monitors'], capture_output=True, text=True, timeout=5)
            print(f"üîç DEBUG: hyprctl monitors returncode: {result.returncode}")
            if result.returncode != 0:
                print(f"üîç DEBUG: hyprctl failed, using fallback resolutions")
                return [1920, 1680, 1440, 1280, 1024], 1920  # fallback resolutions

            # Extract current resolution and available modes
            current_resolution = 1920
            widths = set()

            print(f"üîç DEBUG: hyprctl output length: {len(result.stdout)} chars")
            print(f"üîç DEBUG: First 200 chars: {result.stdout[:200]}")

            for line in result.stdout.split('\n'):
                # Get current resolution from tab-indented line like "\t2560x1440@60.00100 at 0x0"
                if '@' in line and 'x' in line and not 'availableModes:' in line:
                    if line.strip() and line.startswith('\t') and ' at ' in line:
                        try:
                            resolution_part = line.strip().split('@')[0]
                            if 'x' in resolution_part:
                                current_resolution = int(resolution_part.split('x')[0])
                        except (ValueError, IndexError):
                            pass

                # Get available modes
                if 'availableModes:' in line:
                    modes = line.split('availableModes:')[1].strip()
                    for mode in modes.split():
                        if 'x' in mode and '@' in mode:
                            width = mode.split('x')[0]
                            try:
                                widths.add(int(width))
                            except ValueError:
                                continue

            # Sort and take up to 5 largest resolutions
            sorted_widths = sorted(widths, reverse=True)[:5]
            available_widths = sorted_widths if sorted_widths else [1920, 1680, 1440, 1280, 1024]

            print(f"üîç DEBUG: Found {len(widths)} unique widths: {sorted(widths)}")
            print(f"üîç DEBUG: Available widths: {available_widths}")
            print(f"üîç DEBUG: Current resolution: {current_resolution}")

            return available_widths, current_resolution

        except Exception as e:
            print(f"üö® DEBUG: Exception in get_available_resolutions: {e}")
            print(f"üö® DEBUG: Exception type: {type(e)}")
            return [1920, 1680, 1440, 1280, 1024], 1920  # fallback resolutions

    def setup_controls(self):
        """Setup display settings controls"""
        display_config = self.config.get_display_config()

        # Get available resolutions and current resolution
        print("üîç DEBUG: Starting DisplayWidget setup_controls...")
        try:
            self.available_resolutions, current_resolution = self.get_available_resolutions()
            print(f"üîç DEBUG: Got resolutions: {self.available_resolutions}, current: {current_resolution}")
        except Exception as e:
            print(f"üö® DEBUG: Failed to get resolutions: {e}")
            self.available_resolutions, current_resolution = [1920, 1680, 1440, 1280, 1024], 1920

        # Always use actual current resolution, not stored config value
        display_config['resolution'] = current_resolution

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(display_config['enabled'])
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Resolution slider
        print("üîç DEBUG: Creating resolution_box...")
        resolution_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        print("‚úì DEBUG: resolution_box created successfully")

        # Create evenly spaced resolution scale (0 to 4 positions)
        print(f"üîç DEBUG: Creating resolution scale with range 0 to {len(self.available_resolutions)-1}")
        print(f"üîç DEBUG: Available resolutions count: {len(self.available_resolutions)}")
        print(f"üîç DEBUG: Available resolutions: {self.available_resolutions}")

        # Ensure we have at least 2 resolutions for a valid slider range
        if len(self.available_resolutions) < 2:
            print(f"üö® DEBUG: Not enough resolutions ({len(self.available_resolutions)}), using fallback")
            self.available_resolutions = [1920, 1680, 1440, 1280, 1024]
            current_resolution = 1920
            display_config['resolution'] = current_resolution

        max_range = max(1, len(self.available_resolutions)-1)  # Ensure max is at least 1
        print(f"üîç DEBUG: Using slider range 0 to {max_range}")

        try:
            self.resolution_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 0, max_range, 1)
            print("‚úì DEBUG: resolution_scale created successfully")
        except Exception as e:
            print(f"üö® DEBUG: Failed to create resolution_scale: {e}")
            print(f"üö® DEBUG: Exception type: {type(e)}")
            raise

        # Set to current resolution index
        print(f"üîç DEBUG: Finding current resolution index for {display_config['resolution']}")
        current_index = 0
        for i, res in enumerate(self.available_resolutions):
            if res == display_config['resolution']:
                current_index = i
                break
        print(f"üîç DEBUG: Current resolution index: {current_index}")

        try:
            self.resolution_scale.set_value(current_index)
            print("‚úì DEBUG: resolution_scale value set successfully")
        except Exception as e:
            print(f"üö® DEBUG: Failed to set resolution_scale value: {e}")
            raise
        print("üîç DEBUG: Setting resolution_scale properties...")
        try:
            self.resolution_scale.set_draw_value(False)
            print("‚úì DEBUG: set_draw_value(False) successful")

            self.resolution_scale.set_sensitive(display_config['enabled'])
            print("‚úì DEBUG: set_sensitive successful")

            self.resolution_scale.set_margin_start(50)
            print("‚úì DEBUG: set_margin_start successful")

            self.resolution_scale.set_margin_end(50)
            print("‚úì DEBUG: set_margin_end successful")

            self.resolution_scale.connect("value-changed", self.on_resolution_changed)
            print("‚úì DEBUG: connect signal successful")
        except Exception as e:
            print(f"üö® DEBUG: Failed to set resolution_scale properties: {e}")
            raise

        # Add evenly spaced tick marks with full resolution labels
        resolution_labels = ["2560√ó1440", "1920√ó1080", "1680√ó1050", "1600√ó1200", "1440√ó900"]
        for i, label in enumerate(resolution_labels):
            self.resolution_scale.add_mark(i, Gtk.PositionType.BOTTOM, label)

        resolution_box.append(self.resolution_scale)
        self.controls_box.append(resolution_box)

        # Scaling slider (100%, 125%, 150%, 175%, 200%)
        scaling_values = [100, 125, 150, 175, 200]
        scaling_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        self.scaling_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 100, 200, 1)
        self.scaling_scale.set_value(display_config['scaling'])
        self.scaling_scale.set_draw_value(False)
        self.scaling_scale.set_sensitive(display_config['enabled'])
        self.scaling_scale.connect("value-changed", self.on_scaling_changed)

        # Add scaling tick marks
        for scaling in scaling_values:
            self.scaling_scale.add_mark(scaling, Gtk.PositionType.BOTTOM, f"{scaling}%")

        scaling_box.append(self.scaling_scale)
        self.controls_box.append(scaling_box)

    def snap_to_nearest(self, value, valid_values):
        """Snap value to nearest valid option"""
        return min(valid_values, key=lambda x: abs(x - value))

    def on_toggle(self, switch, param):
        """Handle toggle switch"""
        state = switch.get_active()

        # Update slider sensitivity
        self.resolution_scale.set_sensitive(state)
        self.scaling_scale.set_sensitive(state)

        # Mark changes pending
        self.mark_changes_pending()

    def on_resolution_changed(self, scale):
        """Handle resolution change with snapping"""
        value = scale.get_value()
        # Snap to nearest resolution index
        snapped_value = round(value)

        if abs(value - snapped_value) > 0.5:
            scale.set_value(snapped_value)
            return

        # Apply resolution change immediately
        index = int(snapped_value)
        if 0 <= index < len(self.available_resolutions):
            resolution = self.available_resolutions[index]
            self.apply_resolution_change(resolution)

        # Mark changes pending
        self.mark_changes_pending()

    def on_scaling_changed(self, scale):
        """Handle scaling change with snapping"""
        value = scale.get_value()
        snapped_value = self.snap_to_nearest(value, [100, 125, 150, 175, 200])

        if abs(value - snapped_value) > 0.5:
            scale.set_value(snapped_value)
            return

        # Apply scaling change immediately
        self.apply_scaling_change(int(snapped_value))

        # Mark changes pending
        self.mark_changes_pending()

    def apply_resolution_change(self, resolution):
        """Apply resolution change immediately to system"""
        try:
            import subprocess
            # Find current monitor - get the first active monitor
            result = subprocess.run(['hyprctl', 'monitors'], capture_output=True, text=True)
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for line in lines:
                    if line.startswith('Monitor ') and '(ID' in line:
                        monitor_name = line.split(' ')[1]
                        # Set resolution on this monitor
                        subprocess.run(['hyprctl', 'keyword', 'monitor', f'{monitor_name},{resolution}x1440,0x0,1'], check=False)
                        break
        except Exception:
            pass  # Silently fail if hyprctl is not available

    def apply_scaling_change(self, scaling):
        """Apply scaling change immediately to system"""
        try:
            import subprocess
            scale_factor = scaling / 100.0
            # Find current monitor and apply scaling
            result = subprocess.run(['hyprctl', 'monitors'], capture_output=True, text=True)
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for line in lines:
                    if line.startswith('Monitor ') and '(ID' in line:
                        monitor_name = line.split(' ')[1]
                        # Get current resolution from the monitor output
                        for monitor_line in lines:
                            if monitor_line.strip().startswith('2560x') or monitor_line.strip().startswith('1920x'):
                                current_res = monitor_line.strip().split('@')[0]
                                subprocess.run(['hyprctl', 'keyword', 'monitor', f'{monitor_name},{current_res},0x0,{scale_factor}'], check=False)
                                break
                        break
        except Exception:
            pass  # Silently fail if hyprctl is not available

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        enabled = self.switch.get_active()
        resolution = self.snap_to_nearest(self.resolution_scale.get_value(), self.available_resolutions)
        scaling = self.snap_to_nearest(self.scaling_scale.get_value(), [100, 125, 150, 175, 200])

        # Save to config
        self.config.set_display_config(enabled, resolution, scaling)

class InputWidget(BaseControlWidget):
    """Input devices control widget"""

    def __init__(self, config):
        super().__init__(config, "Input Devices", "Keyboard/mouse/touchpad settings", "‚å®Ô∏è")
        self.setup_controls()

    def setup_controls(self):
        """Setup input devices controls"""
        placeholder = Gtk.Label()
        placeholder.set_markup('<span alpha="60%">Input device settings will be added here</span>')
        placeholder.set_margin_top(10)
        placeholder.set_margin_bottom(10)
        self.controls_box.append(placeholder)

class PowerWidget(BaseControlWidget):
    """Power management control widget"""

    def __init__(self, config, window=None):
        super().__init__(config, "Power Management", "Battery and performance profiles", "üîã")
        self.window = window
        self.setup_controls()

    def get_available_profiles(self):
        """Get available power profiles from powerprofilesctl"""
        # Standard profiles only
        standard_profiles = ['power-saver', 'balanced', 'performance']

        try:
            import subprocess
            result = subprocess.run(['powerprofilesctl', 'get'], capture_output=True, text=True)
            if result.returncode == 0:
                current_profile = result.stdout.strip()
                # Ensure current profile is in standard list
                if current_profile not in standard_profiles:
                    current_profile = 'balanced'
                return standard_profiles, current_profile
            return standard_profiles, 'balanced'  # fallback
        except Exception:
            return standard_profiles, 'balanced'  # fallback

    def setup_controls(self):
        """Setup power management controls"""
        power_config = self.config.get_power_config()

        # Get available profiles and current profile
        self.available_profiles, current_profile = self.get_available_profiles()

        # Use actual system profile, not config
        if current_profile in self.available_profiles:
            power_config['profile'] = current_profile

        # Profile label (add to title row)
        profile_names = ["Power Saver", "Balanced", "Performance"]
        current_index = 0
        for i, profile in enumerate(self.available_profiles):
            if profile == current_profile:
                current_index = i
                break
        self.profile_label = Gtk.Label()
        self.profile_label.set_markup(f'<span size="11000" alpha="75%">Profile: {profile_names[current_index]}</span>')
        self.profile_label.set_halign(Gtk.Align.END)
        self.title_row.append(self.profile_label)

        # Enable/Disable toggle (add to title row - RIGHTMOST)
        self.switch = Gtk.Switch()
        self.switch.set_active(power_config['enabled'])
        self.switch.connect("notify::active", self.on_toggle)
        self.title_row.append(self.switch)

        # Power profile slider with icons
        self.available_profiles = ["power-saver", "balanced", "performance"]
        power_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        self.profile_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 0, len(self.available_profiles)-1, 1)

        # Set to current profile
        current_index = 0
        for i, profile in enumerate(self.available_profiles):
            if profile == current_profile:
                current_index = i
                break

        self.profile_scale.set_value(current_index)
        self.profile_scale.set_draw_value(False)
        self.profile_scale.set_sensitive(power_config['enabled'])
        self.profile_scale.set_margin_start(100)
        self.profile_scale.set_margin_end(100)
        self.profile_scale.connect("value-changed", self.on_profile_changed)

        # Add tick marks with correct icons
        self.profile_scale.add_mark(0, Gtk.PositionType.BOTTOM, "üê¢ Power Saver")
        self.profile_scale.add_mark(1, Gtk.PositionType.BOTTOM, "‚öñÔ∏è Balanced")
        self.profile_scale.add_mark(2, Gtk.PositionType.BOTTOM, "‚ö° Performance")

        power_box.append(self.profile_scale)
        self.controls_box.append(power_box)

    def on_toggle(self, switch, param):
        """Handle toggle switch"""
        state = switch.get_active()

        # Update slider sensitivity
        self.profile_scale.set_sensitive(state)

        # Mark changes pending
        self.mark_changes_pending()

    def on_profile_changed(self, scale):
        """Handle profile change with snapping"""
        value = scale.get_value()
        # Snap to nearest profile index
        snapped_value = round(value)

        if abs(value - snapped_value) > 0.1:
            scale.set_value(snapped_value)
            return

        # Apply profile change immediately
        index = int(snapped_value)
        if 0 <= index < len(self.available_profiles):
            profile_names = ["Power Saver", "Balanced", "Performance"]
            self.profile_label.set_markup(f'<span size="11000" alpha="75%">Profile: {profile_names[index]}</span>')

            profile = self.available_profiles[index]
            try:
                import subprocess
                subprocess.run(['powerprofilesctl', 'set', profile], check=False)
            except Exception:
                pass

        # Mark changes pending
        self.mark_changes_pending()

    def mark_changes_pending(self):
        """Mark that changes are pending"""
        if self.window:
            self.window.has_unsaved_changes = True

    def apply_changes(self):
        """Apply all pending changes"""
        enabled = self.switch.get_active()
        selected_index = int(self.profile_scale.get_value())
        profile = self.available_profiles[selected_index] if selected_index < len(self.available_profiles) else 'balanced'

        # Save to config
        self.config.set_power_config(enabled, profile)

        # Apply to system if enabled
        if enabled:
            try:
                import subprocess
                subprocess.run(['powerprofilesctl', 'set', profile], check=True)
            except Exception:
                pass  # Silently fail if powerprofilesctl is not available

class SecurityWidget(BaseControlWidget):
    """Security control widget"""

    def __init__(self, config):
        super().__init__(config, "Security", "Firewall and security settings", "üõ°Ô∏è")
        self.setup_controls()

    def setup_controls(self):
        """Setup security controls"""
        placeholder = Gtk.Label()
        placeholder.set_markup('<span alpha="60%">Security settings will be added here</span>')
        placeholder.set_margin_top(10)
        placeholder.set_margin_bottom(10)
        self.controls_box.append(placeholder)

class ControlPanelWindow:
    """Main control panel window that assembles all widgets"""

    def __init__(self):
        # Initialize configuration
        self.config = ArchRiotConfig()

        # Initialize state tracking
        self.has_unsaved_changes = False

        # Store original config for "Exit without Saving"
        self.original_config = self.backup_current_config()

        # Create main window
        self.window = Gtk.Window()
        self.window.set_title("ArchRiot Control Panel")
        self.window.set_default_size(900, 700)
        self.window.set_resizable(True)
        self.window.set_modal(True)
        self.window.add_css_class("archriot-control-panel")

        # Create main layout
        self.create_layout()

        # Connect window events
        self.window.connect("close-request", self.on_window_close)

    def create_layout(self):
        # Create the main window layout
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        main_box.set_margin_start(15)
        main_box.set_margin_end(15)
        main_box.set_margin_top(10)
        main_box.set_margin_bottom(2)

        # Header
        self.add_header(main_box)

        # Content area with widgets
        self.add_content_area(main_box)

        # Footer
        self.add_footer(main_box)

        self.window.set_child(main_box)

    def add_header(self, container):
        """Add header with title and version info"""
        header_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)

        # Main title
        title_label = Gtk.Label()
        title_label.set_markup('<span size="24000" weight="bold" foreground="#bb9af7">ArchRiot Control Panel</span>')
        title_label.set_halign(Gtk.Align.CENTER)
        header_box.append(title_label)

        # Version and description
        version = self.get_archriot_version()
        subtitle_label = Gtk.Label()
        subtitle_label.set_markup(f'<span size="12000" alpha="75%">ArchRiot v{version} ‚Ä¢ Centralized Settings Management</span>')
        subtitle_label.set_halign(Gtk.Align.CENTER)
        header_box.append(subtitle_label)

        container.append(header_box)

    def add_content_area(self, container):
        """Add main content area with control widgets"""
        # Create scrollable content
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        scrolled_window.set_vexpand(True)

        content_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        content_box.set_margin_start(20)
        content_box.set_margin_end(20)
        content_box.set_margin_top(10)
        content_box.set_margin_bottom(2)

        # Create and add widgets
        self.pomodoro_widget = PomodoroWidget(self.config, self)
        content_box.append(self.pomodoro_widget.widget)

        self.bluelight_widget = BlueLightWidget(self.config, self)
        content_box.append(self.bluelight_widget.widget)

        self.mullvad_widget = MullvadWidget(self.config, self)
        content_box.append(self.mullvad_widget.widget)

        self.audio_widget = AudioWidget(self.config, self)
        content_box.append(self.audio_widget.widget)

        self.camera_widget = CameraWidget(self.config, self)
        content_box.append(self.camera_widget.widget)

        self.display_widget = DisplayWidget(self.config, self)
        content_box.append(self.display_widget.widget)

        # TODO: Re-enable these widgets later
        # self.input_widget = InputWidget(self.config)
        # content_box.append(self.input_widget.widget)

        self.power_widget = PowerWidget(self.config, self)
        content_box.append(self.power_widget.widget)

        # TODO: Re-enable these widgets later
        # self.security_widget = SecurityWidget(self.config)
        # content_box.append(self.security_widget.widget)

        scrolled_window.set_child(content_box)
        container.append(scrolled_window)

    def add_footer(self, container):
        """Add footer with action buttons"""
        footer_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        footer_box.set_margin_top(5)
        footer_box.set_margin_bottom(8)

        # Exit without Saving button (left side)
        exit_button = Gtk.Button(label="Exit (No Save)")
        exit_button.connect("clicked", self.on_exit_without_saving)
        footer_box.append(exit_button)

        # Spacer to push Save button to the right
        spacer = Gtk.Box()
        spacer.set_hexpand(True)
        footer_box.append(spacer)

        # Save and Exit button (right side)
        save_button = Gtk.Button(label="Save and Exit")
        save_button.connect("clicked", self.on_save_and_exit)
        save_button.add_css_class("suggested-action")  # Purple/highlighted
        footer_box.append(save_button)

        container.append(footer_box)

    def apply_all_changes(self):
        """Apply all pending changes from all widgets"""
        if hasattr(self, 'pomodoro_widget') and hasattr(self.pomodoro_widget, 'apply_changes'):
            self.pomodoro_widget.apply_changes()
        if hasattr(self, 'bluelight_widget') and hasattr(self.bluelight_widget, 'apply_changes'):
            self.bluelight_widget.apply_changes()
        if hasattr(self, 'mullvad_widget') and hasattr(self.mullvad_widget, 'apply_changes'):
            self.mullvad_widget.apply_changes()
        if hasattr(self, 'audio_widget') and hasattr(self.audio_widget, 'apply_changes'):
            self.audio_widget.apply_changes()
        if hasattr(self, 'camera_widget') and hasattr(self.camera_widget, 'apply_changes'):
            self.camera_widget.apply_changes()
        if hasattr(self, 'display_widget') and hasattr(self.display_widget, 'apply_changes'):
            self.display_widget.apply_changes()
        # TODO: Re-enable these widgets later
        # if hasattr(self, 'input_widget') and hasattr(self.input_widget, 'apply_changes'):
        #     self.input_widget.apply_changes()
        if hasattr(self, 'power_widget') and hasattr(self.power_widget, 'apply_changes'):
            self.power_widget.apply_changes()
        # TODO: Re-enable these widgets later
        # if hasattr(self, 'security_widget') and hasattr(self.security_widget, 'apply_changes'):
        #     self.security_widget.apply_changes()

        self.has_unsaved_changes = False
        print("All changes applied!")

    def on_exit_without_saving(self, button):
        """Handle exit without saving button click - restore original config"""
        self.restore_original_config()
        self.window.close()

    def on_save_and_exit(self, button):
        """Handle save and exit button click"""
        self.apply_all_changes()
        self.window.close()

    def on_window_close(self, window):
        """Handle window close request"""
        if hasattr(self, 'app'):
            self.app.quit()
        return False

    def backup_current_config(self):
        """Backup current config state for restoration"""
        try:
            return {
                'pomodoro': self.config.get_pomodoro_config(),
                'bluelight': self.config.get_bluelight_config(),
                'mullvad': self.config.get_mullvad_config(),
                'display': self.config.get_display_config(),
                'power': self.config.get_power_config()
            }
        except:
            return {}

    def restore_original_config(self):
        """Restore config to original state"""
        try:
            if hasattr(self, 'original_config') and self.original_config:
                if 'pomodoro' in self.original_config:
                    p = self.original_config['pomodoro']
                    self.config.set_pomodoro_config(p['enabled'], p['duration'])
                if 'bluelight' in self.original_config:
                    b = self.original_config['bluelight']
                    self.config.set_bluelight_config(b['enabled'], b['temperature'])
                if 'mullvad' in self.original_config:
                    m = self.original_config['mullvad']
                    self.config.set_mullvad_config(m['enabled'], m['account_number'], m['auto_connect'])
                if 'display' in self.original_config:
                    d = self.original_config['display']
                    self.config.set_display_config(d['enabled'], d['resolution'], d['scaling'])
                if 'power' in self.original_config:
                    pw = self.original_config['power']
                    self.config.set_power_config(pw['enabled'], pw['profile'])
        except Exception as e:
            print(f"Config restore error: {e}")

    def get_archriot_version(self):
        """Read ArchRiot version from VERSION file"""
        home_dir = Path.home()
        version_path = home_dir / '.local' / 'share' / 'archriot' / 'VERSION'

        try:
            with open(version_path, 'r') as f:
                version = f.read().strip()
                return version
        except Exception:
            return "unknown"

class ControlPanelApplication(Gtk.Application):
    """GTK Application wrapper"""

    def __init__(self):
        super().__init__(application_id="net.archriot.control-panel")

    def do_activate(self):
        """Activate the application"""
        if not self.get_windows():
            window = ControlPanelWindow()
            window.app = self
            self.add_window(window.window)

        # Apply CSS styling
        self.apply_css()

        # Show the window
        self.get_windows()[0].present()

    def apply_css(self):
        """Apply ArchRiot theming"""
        css_provider = Gtk.CssProvider()
        css_data = """
        * {
            font-family: "Hack Nerd Font Mono", "Hack Nerd Font", monospace;
        }

        window {
            background: rgba(0, 0, 0, 1.0);
            color: #cdd6f4;
            font-family: "Hack Nerd Font Mono", "Hack Nerd Font", monospace;
        }

        label {
            color: #cdd6f4;
            font-family: "Hack Nerd Font Mono", "Hack Nerd Font", monospace;
        }

        frame {
            border: 1px solid rgba(157, 123, 216, 0.3);
            border-radius: 8px;
        }



        button {
            background: rgba(75, 0, 130, 1.0);
            color: #ffffff;
            border: none;
            border-radius: 6px;
            padding: 4px 12px;
            font-weight: bold;
            min-height: 24px;
            font-family: "Hack Nerd Font Mono", "Hack Nerd Font", monospace;
        }

        button:hover {
            background: rgba(102, 51, 153, 1.0);
        }



        entry {
            background: rgba(20, 21, 31, 0.9);
            color: #cdd6f4;
            border: 1px solid rgba(157, 123, 216, 0.3);
            border-radius: 6px;
            min-height: 24px;
            padding: 4px 8px;
        }

        entry:focus {
            border: 1px solid rgba(187, 154, 247, 0.6);
        }

        scrolledwindow {
            border: none;
            background: rgba(0, 0, 0, 0.7);
        }
        """

        css_provider.load_from_data(css_data.encode())

        # Apply CSS to default display
        display = Gdk.Display.get_default()
        Gtk.StyleContext.add_provider_for_display(
            display,
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_USER
        )

def main():
    """Main entry point"""
    app = ControlPanelApplication()
    return app.run(sys.argv)

if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)
