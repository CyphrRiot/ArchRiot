package displays

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// Autogen generates a kanshi configuration based on current Hyprland monitors.
// It creates per-output "docked-<name>" profiles that enable that external output
// and disable all internal panels, plus "undocked-<name>" profiles enabling each
// internal panel individually. As a fallback (no internal panels detected and only
// one monitor present), it creates a generic "undocked" profile that enables the
// first monitor.
//
// Returns 0 on success, 1 on errors (and prints a diagnostic).
func Autogen() int {
	// Ensure hyprctl is available and query monitors JSON
	if _, err := exec.LookPath("hyprctl"); err != nil {
		fmt.Fprintln(os.Stderr, "hyprctl not found in PATH")
		return 1
	}

	out, err := exec.Command("hyprctl", "-j", "monitors").CombinedOutput()
	if err != nil || len(strings.TrimSpace(string(out))) == 0 {
		fmt.Fprintln(os.Stderr, "hyprctl not available or no monitors detected")
		return 1
	}

	type mon struct {
		Name    string  `json:"name"`
		ID      int     `json:"id"`
		Focused bool    `json:"focused"`
		X       int     `json:"x"`
		Y       int     `json:"y"`
		Width   int     `json:"width"`
		Height  int     `json:"height"`
		Scale   float64 `json:"scale"`
	}
	var mons []mon
	if err := json.Unmarshal(out, &mons); err != nil || len(mons) == 0 {
		fmt.Fprintln(os.Stderr, "failed to parse hyprctl monitors JSON")
		return 1
	}

	// Classify outputs by name
	hasExternal := false
	var externals []string
	var internals []string
	for _, m := range mons {
		n := m.Name
		up := strings.ToUpper(n)
		// Treat typical laptop panels as internal (EDP/LVDS/DSI)
		isInternal := strings.HasPrefix(up, "EDP-") || strings.Contains(up, "EDP") ||
			strings.HasPrefix(up, "LVDS") || strings.HasPrefix(up, "DSI")
		if isInternal {
			internals = append(internals, n)
			continue
		}
		hasExternal = true
		externals = append(externals, n)
	}

	var b strings.Builder
	b.WriteString("# Auto-generated by archriot --kanshi-autogen\n")
	b.WriteString("# Leave 'scale' unset to allow Control Panel scaling.\n\n")

	// Docked profiles: for each detected external, enable it and disable all internals
	if len(externals) > 0 {
		for _, ext := range externals {
			prof := "docked-" + strings.ReplaceAll(ext, " ", "_")
			b.WriteString("profile " + prof + " {\n")
			b.WriteString("  output " + ext + " enable\n")
			for _, in := range internals {
				b.WriteString("  output " + in + " disable\n")
			}
			b.WriteString("}\n\n")
		}
	}

	// Undocked profiles: enable each internal on its own
	if len(internals) > 0 {
		for _, in := range internals {
			prof := "undocked-" + strings.ReplaceAll(in, " ", "_")
			b.WriteString("profile " + prof + " {\n")
			b.WriteString("  output " + in + " enable\n")
			b.WriteString("}\n\n")
		}
	} else if !hasExternal && len(mons) > 0 {
		// Fallback: no internal detected, enable the first available monitor
		b.WriteString("profile undocked {\n")
		b.WriteString("  output " + mons[0].Name + " enable\n")
		b.WriteString("}\n")
	}

	// Write to ~/.config/kanshi/config
	home := os.Getenv("HOME")
	if strings.TrimSpace(home) == "" {
		if h, err := os.UserHomeDir(); err == nil {
			home = h
		}
	}
	if strings.TrimSpace(home) == "" {
		fmt.Fprintln(os.Stderr, "unable to determine HOME for kanshi config path")
		return 1
	}

	cfgDir := filepath.Join(home, ".config", "kanshi")
	if err := os.MkdirAll(cfgDir, 0o755); err != nil {
		fmt.Fprintf(os.Stderr, "failed to create kanshi config dir: %v\n", err)
		return 1
	}
	cfgPath := filepath.Join(cfgDir, "config")
	if err := os.WriteFile(cfgPath, []byte(b.String()), 0o644); err != nil {
		fmt.Fprintf(os.Stderr, "failed to write kanshi config: %v\n", err)
		return 1
	}

	fmt.Println("âœ“ Wrote kanshi config:", cfgPath)
	fmt.Println("Tip: reload kanshi: pkill kanshi; kanshi &")
	return 0
}
